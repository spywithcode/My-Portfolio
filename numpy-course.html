<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!--=============== FAVICON ===============-->
    <link rel="shortcut icon" href="assets/logo.png" type="image/x-icon">

    <title>NumPy Course - My Portfolio</title>

    <link rel="stylesheet" href="CSS/style.css">
    <link rel="stylesheet" href="skins/color-1.css"> <!-- change skin color here -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

    <!-- ------ RemixIcon ------- -->
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">

    <!-- style switcher  -->
    <link rel="stylesheet" href="skins/color-1.css" class="alternate-style" title="color-1" disabled>
    <link rel="stylesheet" href="skins/color-2.css" class="alternate-style" title="color-2" disabled>
    <link rel="stylesheet" href="skins/color-3.css" class="alternate-style" title="color-3" disabled>
    <link rel="stylesheet" href="skins/color-4.css" class="alternate-style" title="color-4" disabled>
    <link rel="stylesheet" href="skins/color-5.css" class="alternate-style" title="color-5" disabled>

    <link rel="stylesheet" href="CSS/style-switcher.css">
</head>

<body>
    <!-- main container start  -->
    <div class="main-container">
        <!-- Aside start  -->
        <div class="aside">
            <div class="logo">
                <a href="index.html"><span>C</span>oder</a>
            </div>
            <div class="nav-toggler">
                <span></span>
            </div>
            <ul class="nav">
                <li><a href="index.html#home"><i class="fa fa-home"></i>HOME</a></li>
                <li><a href="index.html#about"><i class="fa fa-user"></i>ABOUT</a></li>
                <li><a href="index.html#services"><i class="fa fa-list"></i>SERVICES</a></li>
                <li><a href="index.html#classes"><i class="fa fa-graduation-cap"></i>CLASSES</a></li>
                <li><a href="index.html#portfolio"><i class="fa fa-briefcase"></i>PORTFOLIO</a></li>
                <li><a href="index.html#contact"><i class="fa fa-comments"></i>CONTACT</a></li>
            </ul>
        </div>
        <!-- Aside End  -->

        <!-- main contact start  -->
        <div class="main-contact">
            <!-- NumPy Course Section -->
            <section class="course section active" id="numpy-course">
                <div class="container">
                    <div class="row">
                        <div class="section-title padd-15">
                            <h2>NumPy Course</h2>
                        </div>
                    </div>
                    <div class="row">
                        <div class="course-content padd-15">
                            <div class="about-text padd-15">
                                <hr>
                                <h2>1. Introduction to NumPy (Basics)</h2>
                                <hr>

                                <h3>1.1 What is NumPy?</h3>

                                <p>NumPy ka full form <b>Numerical Python</b> hai.</p>

                                <p>
                                    NumPy Python ki ek core library hai jo <b>numerical aur scientific computation</b>
                                    ke liye use hoti hai.
                                </p>

                                <p>
                                    Data Science, Machine Learning, Artificial Intelligence, Pandas aur
                                    Scikit-Learn jaise tools internally NumPy par depend karte hain.
                                </p>

                                <p><b>Simple words me:</b></p>
                                <p>
                                    NumPy Python ki ek library hai jo <b>fast calculation</b> aur
                                    <b>large data</b> ko efficiently handle karne me madad karti hai.
                                </p>

                                <p>
                                    NumPy ka sabse powerful feature iska array hota hai jise
                                    <b>ndarray</b> kehte hain.
                                </p>

                                <hr>

                                <h3>ndarray kya hota hai?</h3>

                                <p>
                                    ndarray NumPy ka <b>main data structure</b> hota hai.
                                </p>

                                <p>
                                    ndarray ka full form <b>N-Dimensional Array</b> hai.
                                </p>

                                <p>
                                    Ye 1D, 2D, 3D ya multi-dimensional ho sakta hai.
                                </p>

                                <ul>
                                    <li>1D Array → [10, 20, 30]</li>
                                    <li>2D Array → Matrix (rows × columns)</li>
                                    <li>3D Array → Multiple matrices ka collection</li>
                                </ul>

                                <p>
                                    Real-world data mostly 2D ya 3D form me hota hai.
                                </p>

                                <hr>

                                <h3>Why NumPy is faster than Python List?</h3>

                                <ul>
                                    <li>
                                        <b>C Language Backend:</b><br>
                                        NumPy internally C language me likha hota hai,
                                        isliye calculations bahut fast hoti hain.
                                    </li>

                                    <li>
                                        <b>Continuous Memory Allocation:</b><br>
                                        NumPy data ko ek hi continuous memory block me store karta hai,
                                        jisse CPU data ko quickly access karta hai.
                                    </li>

                                    <li>
                                        <b>Fixed Data Type:</b><br>
                                        NumPy array ke sab elements same data type ke hote hain,
                                        isliye processing fast hoti hai.
                                    </li>

                                    <li>
                                        <b>Vectorized Operations:</b><br>
                                        NumPy me loops Python level par nahi,
                                        C level par chalte hain.
                                    </li>

                                    <li>
                                        <b>Broadcasting:</b><br>
                                        Ek hi instruction se poore array par calculation ho jati hai.
                                    </li>
                                </ul>

                                <p>
                                    <b>Result:</b> NumPy operations Python list se
                                    <b>10x–100x tak faster</b> hote hain.
                                </p>

                                <hr>

                                <h3>Difference: Python List vs NumPy Array</h3>

                                <ul>
                                    <li><b>Speed:</b> NumPy fast hota hai, List slow hoti hai</li>
                                    <li><b>Memory:</b> NumPy kam memory use karta hai</li>
                                    <li><b>Data Type:</b> NumPy me same type, List me mixed types</li>
                                    <li><b>Operations:</b> NumPy me direct math possible</li>
                                    <li><b>Usage:</b> NumPy scientific computing ke liye best</li>
                                </ul>

                                <hr>

                                <h3>NumPy Installation and Import</h3>

                                <p>NumPy install karne ke liye:</p>
                                <p><b>pip install numpy</b></p>

                                <p>NumPy import karne ke liye:</p>
                                <p><b>import numpy as np</b></p>

                                <p>
                                    Note: <b>np</b> NumPy ka short name hai
                                    aur ye industry standard hai.
                                </p>

                                <hr>

                                <h3>NumPy Version Check</h3>

                                <p>Installed NumPy ka version check karne ke liye:</p>

                                <p>
                                    <b>
                                        import numpy as np<br>
                                        print(np.__version__)
                                    </b>
                                </p>

                                <hr>

                                <hr>
                                <h2>1.2 NumPy Arrays (ndarray)</h2>
                                <hr>

                                <h3>Creating Arrays in NumPy</h3>

                                <p>
                                    NumPy me array banane ke liye multiple built-in functions available hote hain.
                                </p>

                                <p>
                                    Har function ka use-case alag hota hai.
                                </p>

                                <hr>

                                <h3>1) array() Function</h3>

                                <p>
                                    array() function Python list ko NumPy array me convert karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.array(list)</p>

                                <p><b>Example:</b></p>
                                <p>a = np.array([1, 2, 3])</p>

                                <p><b>Output:</b></p>
                                <p>[1 2 3]</p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Jab data already list ke form me ho</li>
                                </ul>

                                <hr>

                                <h3>2) arange() Function</h3>

                                <p>
                                    arange() function start se stop tak numbers generate karta hai
                                    step size ke saath.
                                </p>

                                <p>
                                    Ye Python ke range() jaisa hota hai,
                                    lekin output NumPy array hota hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.arange(start, stop, step)</p>

                                <p><b>Example:</b></p>
                                <p>np.arange(1, 10, 2)</p>

                                <p><b>Output:</b></p>
                                <p>[1 3 5 7 9]</p>

                                <p><b>Important Points:</b></p>
                                <ul>
                                    <li>Stop value include nahi hoti</li>
                                    <li>Integer aur float dono support karta hai</li>
                                </ul>

                                <hr>

                                <h3>3) linspace() Function</h3>

                                <p>
                                    linspace() function start aur stop ke beech
                                    <b>equal distance</b> wale numbers create karta hai.
                                </p>

                                <p>
                                    Isme total numbers aap decide karte ho.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.linspace(start, stop, number_of_values)</p>

                                <p><b>Example:</b></p>
                                <p>np.linspace(1, 5, 5)</p>

                                <p><b>Output:</b></p>
                                <p>[1. 2. 3. 4. 5.]</p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Graphs ke liye</li>
                                    <li>Mathematics aur ML me evenly spaced data ke liye</li>
                                </ul>

                                <hr>

                                <h3>4) zeros() Function</h3>

                                <p>
                                    zeros() function saare elements 0 se filled array banata hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.zeros(size)</p>

                                <p><b>Example:</b></p>
                                <p>np.zeros(5)</p>

                                <p><b>Output:</b></p>
                                <p>[0. 0. 0. 0. 0.]</p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Initialization ke liye</li>
                                    <li>Counters ya default values ke liye</li>
                                </ul>

                                <hr>

                                <h3>5) ones() Function</h3>

                                <p>
                                    ones() function saare elements 1 se filled array banata hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.ones(size)</p>

                                <p><b>Example:</b></p>
                                <p>np.ones(5)</p>

                                <p><b>Output:</b></p>
                                <p>[1. 1. 1. 1. 1.]</p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Default value 1 chahiye ho</li>
                                    <li>Mathematical operations ke liye</li>
                                </ul>

                                <hr>

                                <h3>6) empty() Function</h3>

                                <p>
                                    empty() function sirf memory allocate karta hai.
                                </p>

                                <p>
                                    Isme values random (garbage) hoti hain,
                                    jo memory par depend karti hain.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.empty(size)</p>

                                <p><b>Example:</b></p>
                                <p>np.empty(4)</p>

                                <p><b>Output:</b></p>
                                <p>Random values (memory dependent)</p>

                                <p><b>Important:</b></p>
                                <ul>
                                    <li>Bahut fast hota hai</li>
                                    <li>Tab use karo jab values baad me fill karni ho</li>
                                </ul>

                                <hr>

                                <h3>7) full() Function</h3>

                                <p>
                                    full() function saare elements ko ek hi given value se fill karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.full(size, value)</p>

                                <p><b>Example:</b></p>
                                <p>np.full(5, 7)</p>

                                <p><b>Output:</b></p>
                                <p>[7 7 7 7 7]</p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Jab same constant value se array chahiye</li>
                                </ul>

                                <hr>

                                <h3>8) eye() Function</h3>

                                <p>
                                    eye() function identity matrix banata hai.
                                </p>

                                <ul>
                                    <li>Diagonal elements = 1</li>
                                    <li>Baaki sab elements = 0</li>
                                </ul>

                                <p><b>Syntax:</b></p>
                                <p>np.eye(rows, columns)</p>

                                <p><b>Example:</b></p>
                                <p>np.eye(3)</p>

                                <p><b>Output:</b></p>
                                <p>
                                    [ [1. 0. 0.]<br>
                                    [0. 1. 0.]<br>
                                    [0. 0. 1.] ]
                                </p>

                                <p><b>Use kab hota hai:</b></p>
                                <ul>
                                    <li>Linear Algebra</li>
                                    <li>Matrix operations</li>
                                    <li>Machine Learning algorithms</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>Array Attributes (NumPy)</h2>
                                <hr>

                                <p>
                                    Array attributes ka use array ki
                                    <b>structure, size, data type aur memory</b>
                                    ko samajhne ke liye hota hai.
                                </p>

                                <p><b>Example Array:</b></p>
                                <p>
                                    a = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]])
                                </p>

                                <hr>

                                <h3>1) shape Attribute</h3>

                                <p><b>Syntax:</b></p>
                                <p>a.shape</p>

                                <p>
                                    shape attribute array ka structure batata hai.
                                </p>

                                <p>
                                    Ye hamesha <b>(rows, columns)</b> ke form me hota hai.
                                </p>

                                <p><b>Output:</b></p>
                                <p>(2, 3)</p>

                                <p><b>Meaning:</b></p>
                                <ul>
                                    <li>2 rows</li>
                                    <li>3 columns</li>
                                </ul>

                                <p><b>Use kab hota hai:</b></p>
                                <ul>
                                    <li>Data ka layout samajhne ke liye</li>
                                    <li>Array reshape karte time</li>
                                </ul>

                                <hr>

                                <h3>2) size Attribute</h3>

                                <p><b>Syntax:</b></p>
                                <p>a.size</p>

                                <p>
                                    size attribute array me total elements ki count batata hai.
                                </p>

                                <p><b>Output:</b></p>
                                <p>6</p>

                                <p><b>Formula:</b></p>
                                <p>rows × columns</p>

                                <hr>

                                <h3>3) dtype Attribute</h3>

                                <p><b>Syntax:</b></p>
                                <p>a.dtype</p>

                                <p>
                                    dtype attribute array ke elements ka data type batata hai.
                                </p>

                                <p><b>Output Examples:</b></p>
                                <ul>
                                    <li>int32</li>
                                    <li>int64</li>
                                    <li>float64</li>
                                </ul>

                                <p><b>Important Point:</b></p>
                                <p>
                                    NumPy array me <b>sab elements same data type</b> ke hote hain.
                                </p>

                                <hr>

                                <h3>4) itemsize Attribute</h3>

                                <p><b>Syntax:</b></p>
                                <p>a.itemsize</p>

                                <p>
                                    itemsize attribute batata hai ki
                                    ek single element kitne <b>bytes</b> memory leta hai.
                                </p>

                                <p><b>Output Examples:</b></p>
                                <ul>
                                    <li>4 bytes (int32 ke liye)</li>
                                    <li>8 bytes (int64 ke liye)</li>
                                </ul>

                                <p><b>Use kab hota hai:</b></p>
                                <ul>
                                    <li>Memory optimization samajhne ke liye</li>
                                </ul>

                                <hr>

                                <h3>5) ndim Attribute</h3>

                                <p><b>Syntax:</b></p>
                                <p>a.ndim</p>

                                <p>
                                    ndim attribute array ke total dimensions batata hai.
                                </p>

                                <p><b>Output:</b></p>
                                <p>2</p>

                                <p><b>Meaning:</b></p>
                                <p>Ye ek 2D array hai.</p>

                                <p><b>Examples:</b></p>
                                <ul>
                                    <li>1D Array → ndim = 1</li>
                                    <li>2D Array → ndim = 2</li>
                                    <li>3D Array → ndim = 3</li>
                                </ul>

                                <hr>

                                <h3>Summary (Yaad rakhne ke liye)</h3>

                                <ul>
                                    <li><b>shape</b> → structure (rows, columns)</li>
                                    <li><b>size</b> → total elements</li>
                                    <li><b>dtype</b> → data type</li>
                                    <li><b>itemsize</b> → memory per element</li>
                                    <li><b>ndim</b> → number of dimensions</li>
                                </ul>

                                <p>
                                    Ye attributes NumPy array ko samajhne ke liye
                                    <b>sabse important</b> hote hain.
                                </p>

                                <hr>

                                <hr>
                                <h2>1.3 Array Indexing</h2>
                                <hr>

                                <h3>What is Array Indexing?</h3>

                                <p>
                                    Indexing ka matlab hota hai array ke
                                    <b>kisi ek single element</b> ko uske index number se access karna.
                                </p>

                                <p>
                                    Indexing ka output hamesha <b>single value</b> hota hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30])<br>
                                    a[1] &nbsp;&nbsp;→ 20
                                </p>

                                <hr>

                                <h3>1D Indexing</h3>

                                <p>
                                    1D array me indexing simple hoti hai aur
                                    <b>index 0 se start hota hai</b>.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([5, 10, 15, 20, 25])
                                </p>

                                <ul>
                                    <li>a[0] → 5</li>
                                    <li>a[2] → 15</li>
                                    <li>a[-1] → 25 (last element)</li>
                                    <li>a[-2] → 20</li>
                                </ul>

                                <p><b>Rules:</b></p>
                                <ul>
                                    <li>Positive index → left se count</li>
                                    <li>Negative index → right se count</li>
                                </ul>

                                <hr>

                                <h3>2D Indexing</h3>

                                <p>
                                    2D array me indexing <b>[row, column]</b> format me hoti hai.
                                </p>

                                <p>
                                    Hamesha pehle <b>row</b>, phir <b>column</b> likhte hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[10, 20, 30],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[40, 50, 60]])
                                </p>

                                <ul>
                                    <li>a[0, 1] → 20</li>
                                    <li>a[1, 2] → 60</li>
                                    <li>a[0, 0] → 10</li>
                                </ul>

                                <p><b>Yaad rakho:</b> Row pehle, Column baad me</p>

                                <hr>

                                <h3>3D Indexing</h3>

                                <p>
                                    3D array me indexing ka format hota hai:
                                    <b>[block, row, column]</b>
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]],<br><br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[7, 8, 9],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[10, 11, 12]]])
                                </p>

                                <ul>
                                    <li>a[0, 1, 2] → 6</li>
                                    <li>a[1, 0, 1] → 8</li>
                                    <li>a[1, 1, 0] → 10</li>
                                </ul>

                                <p><b>Samajhne ka trick:</b></p>
                                <p>
                                    3D array ko <b>shelves → rows → columns</b> ki tarah socho.
                                </p>

                                <hr>

                                <h2>1.4 Array Slicing</h2>
                                <hr>

                                <h3>What is Slicing?</h3>

                                <p>
                                    Slicing ka matlab hota hai array ka
                                    <b>ek portion (sub-array)</b> nikalna.
                                </p>

                                <p>
                                    Slicing ka output hamesha <b>multiple values (array)</b> hota hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>array[start : end : step]</p>

                                <hr>

                                <h3>Step Slicing (1D Array)</h3>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30, 40, 50])
                                </p>

                                <ul>
                                    <li>a[1:4] → [20 30 40]</li>
                                    <li>a[:3] → [10 20 30]</li>
                                    <li>a[2:] → [30 40 50]</li>
                                    <li>a[::2] → [10 30 50]</li>
                                    <li>a[::-1] → [50 40 30 20 10]</li>
                                </ul>

                                <p><b>Important Rules:</b></p>
                                <ul>
                                    <li>Start value include hoti hai</li>
                                    <li>End value exclude hoti hai</li>
                                </ul>

                                <hr>

                                <h3>Extracting Rows (2D Array)</h3>

                                <p>
                                    Row extract karne ke liye sirf row index likhte hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[10, 20, 30],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[40, 50, 60],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[70, 80, 90]])
                                </p>

                                <ul>
                                    <li>a[1] → [40 50 60]</li>
                                    <li>a[0:2] → First two rows</li>
                                </ul>

                                <p><b>Formula:</b></p>
                                <p>a[row_index]</p>

                                <hr>

                                <h3>Extracting Columns (2D Array)</h3>

                                <p>
                                    Column extract karne ke liye:
                                </p>

                                <ul>
                                    <li>Rows ke liye <b>:</b></li>
                                    <li>Column ke liye index</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <ul>
                                    <li>a[:, 0] → [10 40 70]</li>
                                    <li>a[:, 2] → [30 60 90]</li>
                                </ul>

                                <p><b>Formula:</b></p>
                                <p>a[:, column_index]</p>

                                <hr>

                                <h3>Indexing vs Slicing (Quick Difference)</h3>

                                <ul>
                                    <li><b>Indexing</b> → Single value</li>
                                    <li><b>Slicing</b> → Sub-array (multiple values)</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>Boolean Indexing</h2>
                                <hr>

                                <h3>What is Boolean Indexing?</h3>

                                <p>
                                    Boolean indexing me hum array par
                                    <b>condition</b> lagate hain.
                                </p>

                                <p>
                                    Sirf wahi elements select hote hain
                                    jinke liye condition <b>True</b> hoti hai.
                                </p>

                                <p>
                                    Ye technique mainly <b>data filtering</b> ke liye use hoti hai.
                                </p>

                                <hr>

                                <h3>Example 1</h3>

                                <p><b>Array:</b></p>
                                <p>a = np.array([10, 25, 30, 5, 40])</p>

                                <p><b>Code:</b></p>
                                <p>a[a &gt; 20]</p>

                                <p><b>Output:</b></p>
                                <p>[25 30 40]</p>

                                <p><b>Explanation:</b></p>
                                <p>
                                    Condition <b>a &gt; 20</b> ek boolean array banata hai:
                                </p>
                                <p>[False True True False True]</p>

                                <p>
                                    Jahan condition <b>True</b> hoti hai,
                                    sirf wahi elements return hote hain.
                                </p>

                                <hr>

                                <h3>Example 2 (Even Numbers)</h3>

                                <p><b>Code:</b></p>
                                <p>a[a % 2 == 0]</p>

                                <p><b>Output:</b></p>
                                <p>[10 30 40]</p>

                                <hr>

                                <h3>Use Cases of Boolean Indexing</h3>

                                <ul>
                                    <li>Data filtering</li>
                                    <li>Outliers remove karna</li>
                                    <li>Condition based analysis</li>
                                </ul>

                                <hr>

                                <h2>Fancy Indexing</h2>
                                <hr>

                                <h3>What is Fancy Indexing?</h3>

                                <p>
                                    Fancy indexing me hum ek saath
                                    <b>multiple specific indexes</b> access kar sakte hain.
                                </p>

                                <p>
                                    Isme normal index ki jagah
                                    <b>list ya NumPy array of indexes</b> use hoti hai.
                                </p>

                                <hr>

                                <h3>Example (1D Fancy Indexing)</h3>

                                <p><b>Array:</b></p>
                                <p>a = np.array([10, 20, 30, 40, 50])</p>

                                <p><b>Code:</b></p>
                                <p>a[[0, 2, 4]]</p>

                                <p><b>Output:</b></p>
                                <p>[10 30 50]</p>

                                <hr>

                                <h3>Example (2D Fancy Indexing)</h3>

                                <p><b>Array:</b></p>
                                <p>
                                    b = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[7, 8, 9]])
                                </p>

                                <p><b>Code:</b></p>
                                <p>b[[0, 2], [1, 2]]</p>

                                <p><b>Output:</b></p>
                                <p>[2 9]</p>

                                <p><b>Explanation:</b></p>
                                <ul>
                                    <li>(0, 1) element → 2</li>
                                    <li>(2, 2) element → 9</li>
                                </ul>

                                <hr>

                                <h3>Use Cases of Fancy Indexing</h3>

                                <ul>
                                    <li>Random positions se values lena</li>
                                    <li>Data reordering</li>
                                    <li>Custom selection logic</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>2. Array Operations (Core Concepts)</h2>
                                <hr>

                                <h3>2.1 Arithmetic Operations (Element-wise)</h3>

                                <p><b>Important Rule:</b></p>
                                <ul>
                                    <li>NumPy me arithmetic operations <b>element-wise</b> hoti hain</li>
                                    <li>Same index wale elements par operation lagta hai</li>
                                    <li>Arrays ka shape same hona chahiye (ya broadcastable)</li>
                                </ul>

                                <hr>

                                <h3>1) Element-wise Addition</h3>

                                <p>
                                    Same index ke elements add hote hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30])<br>
                                    b = np.array([1, 2, 3])
                                </p>

                                <p><b>Code:</b></p>
                                <p>c = a + b</p>

                                <p><b>Output:</b></p>
                                <p>[11 22 33]</p>

                                <p><b>Meaning:</b></p>
                                <p>10+1, 20+2, 30+3</p>

                                <hr>

                                <h3>2) Element-wise Subtraction</h3>

                                <p>
                                    Same index ke elements subtract hote hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30])<br>
                                    b = np.array([1, 2, 3])
                                </p>

                                <p><b>Code:</b></p>
                                <p>c = a - b</p>

                                <p><b>Output:</b></p>
                                <p>[9 18 27]</p>

                                <hr>

                                <h3>3) Element-wise Multiplication</h3>

                                <p>
                                    Same index ke elements multiply hote hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([2, 3, 4])<br>
                                    b = np.array([5, 6, 7])
                                </p>

                                <p><b>Code:</b></p>
                                <p>c = a * b</p>

                                <p><b>Output:</b></p>
                                <p>[10 18 28]</p>

                                <p><b>Note:</b></p>
                                <p>
                                    Ye <b>matrix multiplication nahi</b> hai,
                                    ye sirf element-by-element multiplication hai.
                                </p>

                                <hr>

                                <h3>4) Element-wise Division</h3>

                                <p>
                                    Same index ke elements divide hote hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30])<br>
                                    b = np.array([2, 4, 5])
                                </p>

                                <p><b>Code:</b></p>
                                <p>c = a / b</p>

                                <p><b>Output:</b></p>
                                <p>[5. 5. 6.]</p>

                                <p><b>Important:</b></p>
                                <p>
                                    Division ka output hamesha <b>float</b> hota hai.
                                </p>

                                <hr>

                                <h3>5) Element-wise Power</h3>

                                <p>
                                    Har element ko uske matching element ke power me raise kiya jata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([2, 3, 4])<br>
                                    b = np.array([3, 2, 1])
                                </p>

                                <p><b>Code:</b></p>
                                <p>c = a ** b</p>

                                <p><b>Output:</b></p>
                                <p>[8 9 4]</p>

                                <p><b>Explanation:</b></p>
                                <p>2³, 3², 4¹</p>

                                <hr>

                                <h3>6) Element-wise Modulus</h3>

                                <p>
                                    Har element ka remainder (%) nikala jata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 35])<br>
                                    b = np.array([3, 6, 4])
                                </p>

                                <p><b>Code:</b></p>
                                <p>c = a % b</p>

                                <p><b>Output:</b></p>
                                <p>[1 2 3]</p>

                                <hr>

                                <h3>7) Element-wise Comparison</h3>

                                <p>
                                    Matching elements compare hote hain.
                                </p>

                                <p>
                                    Output hamesha <b>Boolean array (True / False)</b> hota hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30])<br>
                                    b = np.array([15, 20, 25])
                                </p>

                                <p><b>Code:</b></p>
                                <p>a == b</p>

                                <p><b>Output:</b></p>
                                <p>[False True False]</p>

                                <p><b>Other Comparisons:</b></p>
                                <ul>
                                    <li>a &gt; b</li>
                                    <li>a &lt; b</li>
                                    <li>a != b</li>
                                    <li>a &gt;= b</li>
                                    <li>a &lt;= b</li>
                                </ul>

                                <hr>

                                <h3>Summary (Yaad rakhne ka shortcut)</h3>

                                <ul>
                                    <li>+ → Addition</li>
                                    <li>- → Subtraction</li>
                                    <li>* → Multiplication</li>
                                    <li>/ → Division</li>
                                    <li>** → Power</li>
                                    <li>% → Modulus</li>
                                    <li>== → Comparison</li>
                                </ul>

                                <p>
                                    Sab operations <b>element-by-element</b> hote hain.
                                </p>

                                <hr>

                                <hr>
                                <h2>2.2 Matrix Operations</h2>
                                <hr>

                                <h3>Matrix Multiplication (dot, matmul, @)</h3>

                                <p>
                                    Matrix multiplication me <b>rows × columns rule</b> follow hota hai.
                                </p>

                                <p>
                                    Pehli matrix ke columns aur doosri matrix ke rows
                                    <b>same hone chahiye</b>.
                                </p>

                                <p><b>Rule:</b></p>
                                <p>
                                    A (m × n) × B (n × p) = Result (m × p)
                                </p>

                                <hr>

                                <h3>Example Matrices</h3>

                                <p>
                                    a = np.array([[1, 2],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3, 4]])
                                </p>

                                <p>
                                    b = np.array([[5, 6],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[7, 8]])
                                </p>

                                <hr>

                                <h3>Matrix Multiplication Methods</h3>

                                <h4>1) dot() function</h4>
                                <p>np.dot(a, b)</p>

                                <h4>2) matmul() function</h4>
                                <p>np.matmul(a, b)</p>

                                <h4>3) @ operator</h4>
                                <p>a @ b</p>

                                <p>
                                    <b>Note:</b> @ operator internally <b>np.matmul()</b> hi use karta hai.
                                </p>

                                <p>
                                    Modern NumPy code me <b>@ operator preferred</b> hota hai.
                                </p>

                                <hr>

                                <h3>Calculation (Row × Column)</h3>

                                <p><b>Result matrix ka har element:</b></p>

                                <ul>
                                    <li>First element: (1×5) + (2×7) = 19</li>
                                    <li>Second element: (1×6) + (2×8) = 22</li>
                                    <li>Third element: (3×5) + (4×7) = 43</li>
                                    <li>Fourth element: (3×6) + (4×8) = 50</li>
                                </ul>

                                <hr>

                                <h3>Final Output (sab me same)</h3>

                                <p>
                                    [[19 22]<br>
                                    &nbsp;[43 50]]
                                </p>

                                <hr>

                                <h3>Important Differences (Exam + Interview)</h3>

                                <ul>
                                    <li>dot() aur matmul() matrix case me <b>same result</b> dete hain</li>
                                    <li>Difference tab aata hai jab <b>1D arrays (vectors)</b> use hote hain</li>
                                </ul>

                                <p><b>dot():</b></p>
                                <ul>
                                    <li>Vector dot product bhi karta hai</li>
                                    <li>1D arrays ke case me <b>scalar value</b> de sakta hai</li>
                                </ul>

                                <p><b>matmul():</b></p>
                                <ul>
                                    <li>Sirf <b>matrix-style multiplication</b> karta hai</li>
                                    <li>1D arrays ke saath bhi matrix rule follow karta hai</li>
                                </ul>

                                <hr>

                                <h3>Very Important Notes (Miss hone wale points)</h3>

                                <ul>
                                    <li>
                                        Shape match nahi hua to <b>ERROR</b> aayega<br>
                                        Example: (2×3) × (2×2) ❌ invalid
                                    </li>

                                    <li>
                                        Element-wise multiplication alag hota hai<br>
                                        a * b ≠ matrix multiplication<br>
                                        a * b → element-wise<br>
                                        a @ b → matrix multiplication
                                    </li>

                                    <li>
                                        1D arrays ke saath behavior different hota hai<br>
                                        Isliye beginners ke liye <b>@ operator safer</b> hota hai
                                    </li>
                                </ul>

                                <hr>

                                <h3>Shortcut (Yaad rakhne ke liye)</h3>

                                <ul>
                                    <li>* → element-wise multiplication</li>
                                    <li>@ → matrix multiplication</li>
                                    <li>dot → vector + matrix (context dependent)</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>2.3 Mathematical Functions (NumPy)</h2>
                                <hr>

                                <p>
                                    NumPy Mathematical Functions <b>element-wise</b> kaam karte hain.
                                </p>

                                <p>
                                    Matlab array ke <b>har element</b> par function apply hota hai.
                                </p>

                                <hr>

                                <h3>np.sqrt()</h3>

                                <p>
                                    Har element ka <b>square root</b> nikalta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([4, 9, 16, 25])<br>
                                    np.sqrt(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[2. 3. 4. 5.]</p>

                                <p><b>Important:</b></p>
                                <p>
                                    Negative values par <b>NaN</b> aata hai.
                                </p>

                                <hr>

                                <h3>np.exp()</h3>

                                <p>
                                    Har element par <b>e (≈ 2.718)</b> ki power lagata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, 3])<br>
                                    np.exp(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[2.71828183 7.3890561 20.08553692]</p>

                                <hr>

                                <h3>np.log()</h3>

                                <p>
                                    Har element ka <b>natural log (base e)</b> nikalta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, np.e, 10])<br>
                                    np.log(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[0. 1. 2.30258509]</p>

                                <p><b>Important:</b></p>
                                <p>
                                    Input <b>0 ya negative</b> nahi hona chahiye.
                                </p>

                                <hr>

                                <h3>np.sin()</h3>

                                <p>
                                    Har element ka <b>sine value</b> nikalta hai.
                                </p>

                                <p>
                                    NumPy <b>radians</b> me kaam karta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([0, np.pi/2, np.pi])<br>
                                    np.sin(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[0. 1. 0.]</p>

                                <hr>

                                <h3>np.cos()</h3>

                                <p>
                                    Har element ka <b>cosine value</b> nikalta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([0, np.pi/2, np.pi])<br>
                                    np.cos(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[1. 0. -1.]</p>

                                <hr>

                                <h3>np.abs()</h3>

                                <p>
                                    Absolute (positive) value deta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([-5, -2, 0, 3])<br>
                                    np.abs(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[5 2 0 3]</p>

                                <hr>

                                <h3>np.sum()</h3>

                                <p>
                                    Array ke sab elements ka <b>total sum</b> nikalta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30, 40])<br>
                                    np.sum(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>100</p>

                                <p><b>Extra:</b></p>
                                <p>
                                    axis parameter ka use karke row-wise ya column-wise sum nikal sakte hain.
                                </p>

                                <hr>

                                <h3>np.mean()</h3>

                                <p>
                                    Array ka <b>average (mean)</b> nikalta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 20, 30, 40])<br>
                                    np.mean(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>25.0</p>

                                <hr>

                                <h3>np.median()</h3>

                                <p>
                                    Array ka <b>middle value</b> nikalta hai.
                                </p>

                                <p>
                                    Median nikalne se pehle data ko sort kiya jata hai.
                                </p>

                                <p><b>Example (Odd elements):</b></p>
                                <p>
                                    a = np.array([10, 30, 20])<br>
                                    np.median(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>20</p>

                                <p><b>Example (Even elements):</b></p>
                                <p>
                                    a = np.array([10, 20, 30, 40])<br>
                                    np.median(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>25.0</p>

                                <p><b>Use kab kare:</b></p>
                                <p>
                                    Jab data me <b>outliers</b> ho aur mean misleading ho.
                                </p>

                                <hr>

                                <h3>np.max()</h3>

                                <p>
                                    Array ki <b>maximum value</b> deta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 45, 23, 60])<br>
                                    np.max(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>60</p>

                                <hr>

                                <h3>np.min()</h3>

                                <p>
                                    Array ki <b>minimum value</b> deta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 45, 23, 60])<br>
                                    np.min(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>10</p>

                                <hr>

                                <h3>np.argmax()</h3>

                                <p>
                                    <b>Maximum value ka index</b> batata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 45, 23, 60])<br>
                                    np.argmax(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>3</p>

                                <p>
                                    Matlab 60 index 3 par hai.
                                </p>

                                <hr>

                                <h3>np.argmin()</h3>

                                <p>
                                    <b>Minimum value ka index</b> batata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([10, 45, 23, 60])<br>
                                    np.argmin(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>0</p>

                                <p>
                                    Matlab 10 index 0 par hai.
                                </p>

                                <hr>

                                <h3>Very Important Summary (Exam Gold)</h3>

                                <ul>
                                    <li>sum → total</li>
                                    <li>mean → average</li>
                                    <li>median → middle value</li>
                                    <li>max → largest value</li>
                                    <li>min → smallest value</li>
                                    <li>argmax → max ka index</li>
                                    <li>argmin → min ka index</li>
                                </ul>

                                <p>
                                    <b>Note:</b> argmax / argmin <b>value nahi</b>, sirf <b>index</b> dete hain.
                                </p>

                                <hr>

                                <hr>
                                <h2>Transpose</h2>
                                <hr>

                                <p>
                                    Transpose me matrix ki <b>rows columns</b> ban jati hain
                                    aur <b>columns rows</b>.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]])
                                </p>

                                <p><b>Code:</b></p>
                                <p>a.T</p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[1 4]<br>
                                    &nbsp;[2 5]<br>
                                    &nbsp;[3 6]]
                                </p>

                                <p><b>Important Notes:</b></p>
                                <ul>
                                    <li>a.T ek <b>view</b> return karta hai, copy nahi</li>
                                    <li>Original array change nahi hota</li>
                                    <li>Transpose ka use:
                                        <ul>
                                            <li>Matrix multiplication</li>
                                            <li>Linear algebra</li>
                                            <li>Data alignment</li>
                                        </ul>
                                    </li>
                                </ul>

                                <hr>

                                <h2>Determinant</h2>
                                <hr>

                                <p>
                                    Determinant ek <b>single number</b> hota hai.
                                </p>

                                <p>
                                    Sirf <b>square matrix (n×n)</b> ka determinant hota hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3, 4]])
                                </p>

                                <p><b>Code:</b></p>
                                <p>np.linalg.det(a)</p>

                                <p><b>Output:</b></p>
                                <p>-2.0</p>

                                <p><b>2×2 Formula:</b></p>
                                <p>
                                    | a b |<br>
                                    | c d | = (a×d − b×c)
                                </p>

                                <p><b>Important Notes:</b></p>
                                <ul>
                                    <li>Determinant float me aata hai</li>
                                    <li>Determinant batata hai:
                                        <ul>
                                            <li>Matrix invertible hai ya nahi</li>
                                            <li>System of equations ka solution possible hai ya nahi</li>
                                        </ul>
                                    </li>
                                </ul>

                                <hr>

                                <h2>Matrix Inverse</h2>
                                <hr>

                                <p>
                                    Inverse wo matrix hoti hai jo original matrix ka effect <b>undo</b> kar deti hai.
                                </p>

                                <p><b>Rule:</b></p>
                                <p>A × A<sup>-1</sup> = I (Identity matrix)</p>

                                <p><b>NumPy Example:</b></p>
                                <p>
                                    a = np.array([[1, 2],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3, 4]])
                                </p>

                                <p><b>Code:</b></p>
                                <p>np.linalg.inv(a)</p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[-2. &nbsp;1.]<br>
                                    &nbsp;[1.5 -0.5]]
                                </p>

                                <hr>

                                <h3>2×2 Matrix Inverse (Manual Method)</h3>

                                <p><b>Matrix:</b></p>
                                <p>
                                    | a b |<br>
                                    | c d |
                                </p>

                                <p><b>Step 1: Determinant</b></p>
                                <p>det = (a×d − b×c)</p>

                                <p><b>Step 2: Formula</b></p>
                                <p>
                                    A<sup>-1</sup> = 1/det × | d -b |<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| -c a |
                                </p>

                                <p><b>Very Important:</b></p>
                                <ul>
                                    <li>Determinant 0 nahi hona chahiye</li>
                                    <li>det = 0 ⇒ inverse exist nahi karta</li>
                                    <li>np.linalg.inv() me error aata hai agar det = 0</li>
                                </ul>

                                <hr>

                                <h2>Matrix Rank</h2>
                                <hr>

                                <p>
                                    Rank batata hai matrix me
                                    <b>kitni independent rows ya columns</b> hain.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2, 4]])
                                </p>

                                <p><b>Code:</b></p>
                                <p>np.linalg.matrix_rank(a)</p>

                                <p><b>Output:</b></p>
                                <p>1</p>

                                <p><b>Explanation:</b></p>
                                <p>
                                    Second row, first row ka multiple hai,
                                    isliye sirf 1 independent row hai.
                                </p>

                                <p><b>Important Rules:</b></p>
                                <ul>
                                    <li>Rank ≤ number of rows</li>
                                    <li>Rank ≤ number of columns</li>
                                    <li>Zero matrix ka rank = 0</li>
                                    <li>Full rank ⇒ rank = min(rows, columns)</li>
                                </ul>

                                <hr>

                                <h2>Axis Based Operations (NumPy)</h2>
                                <hr>

                                <h3>Axis ka matlab kya hota hai?</h3>

                                <p>
                                    Axis batata hai calculation <b>kis direction me hogi</b>.
                                </p>

                                <p>
                                    Axis ka matlab hota hai:
                                    <b>kis dimension ko collapse karna hai</b>.
                                </p>

                                <hr>

                                <h3>Simple Golden Rule</h3>

                                <ul>
                                    <li>axis = 0 → column-wise operation</li>
                                    <li>axis = 1 → row-wise operation</li>
                                </ul>

                                <p><b>Memory Trick:</b></p>
                                <p>
                                    axis = 0 → niche ki taraf (rows ke across)<br>
                                    axis = 1 → right ki taraf (columns ke across)
                                </p>

                                <hr>

                                <h3>Example Matrix</h3>

                                <p>
                                    a = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]])
                                </p>

                                <hr>

                                <h3>axis = 0 (Column-wise)</h3>

                                <p><b>Code:</b></p>
                                <p>np.sum(a, axis=0)</p>

                                <p><b>Calculation:</b></p>
                                <ul>
                                    <li>Column 1: 1 + 4 = 5</li>
                                    <li>Column 2: 2 + 5 = 7</li>
                                    <li>Column 3: 3 + 6 = 9</li>
                                </ul>

                                <p><b>Output:</b></p>
                                <p>[5 7 9]</p>

                                <hr>

                                <h3>axis = 1 (Row-wise)</h3>

                                <p><b>Code:</b></p>
                                <p>np.sum(a, axis=1)</p>

                                <p><b>Calculation:</b></p>
                                <ul>
                                    <li>Row 1: 1 + 2 + 3 = 6</li>
                                    <li>Row 2: 4 + 5 + 6 = 15</li>
                                </ul>

                                <p><b>Output:</b></p>
                                <p>[6 15]</p>

                                <hr>

                                <h3>Important Points</h3>

                                <ul>
                                    <li>
                                        Axis sirf sum tak limited nahi hai, ye in functions ke saath kaam karta hai:
                                        <ul>
                                            <li>np.mean()</li>
                                            <li>np.max()</li>
                                            <li>np.min()</li>
                                            <li>np.std()</li>
                                            <li>np.argmax()</li>
                                            <li>np.argmin()</li>
                                        </ul>
                                    </li>

                                    <li>
                                        Axis use karne par output ka <b>dimension kam ho jata hai</b>
                                    </li>
                                </ul>

                                <hr>

                                <h3>Axis ko hamesha kaise samjhein?</h3>

                                <p><b>Step 1:</b> a.shape dekho</p>
                                <p>a.shape = (2, 3)</p>

                                <p><b>Step 2:</b></p>
                                <ul>
                                    <li>axis = 0 ⇒ rows collapse</li>
                                    <li>axis = 1 ⇒ columns collapse</li>
                                </ul>

                                <hr>

                                <h3>One-line Memory Trick</h3>

                                <p>
                                    axis = 0 → columns bachte hain<br>
                                    axis = 1 → rows bachte hain
                                </p>

                                <hr>

                                <hr>
                                <h2>Custom Ufuncs (User Defined Functions)</h2>
                                <hr>

                                <h3>Custom ufunc kya hota hai?</h3>

                                <p>
                                    Custom ufunc ka matlab hai apna function banana jo
                                    <b>NumPy array ke har element par automatically apply</b> ho.
                                </p>

                                <p>
                                    Jab NumPy ka built-in function available na ho,
                                    tab custom ufunc use karte hain.
                                </p>

                                <hr>

                                <h3>Method 1: np.vectorize()</h3>

                                <p>
                                    np.vectorize() Python function ko array-friendly bana deta hai.
                                </p>

                                <ul>
                                    <li>Syntax simple hota hai</li>
                                    <li>Beginner-friendly hai</li>
                                    <li>Internally Python loop hi use hota hai</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    def square(x):<br>
                                    &nbsp;&nbsp;return x * x<br><br>
                                    sq = np.vectorize(square)<br>
                                    a = np.array([1, 2, 3, 4])<br>
                                    sq(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[1 4 9 16]</p>

                                <p><b>Important Reality:</b></p>
                                <ul>
                                    <li>np.vectorize real ufunc nahi hota</li>
                                    <li>Sirf Python loop ko hide karta hai</li>
                                    <li>Performance improvement nahi deta</li>
                                </ul>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Small data ke liye</li>
                                    <li>Learning ya prototyping ke liye</li>
                                    <li>Readability improve karne ke liye</li>
                                </ul>

                                <hr>

                                <h3>Method 2: np.frompyfunc()</h3>

                                <p>
                                    np.frompyfunc() Python function ko NumPy-style ufunc me convert karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.frompyfunc(function, input_count, output_count)</p>

                                <p><b>Example:</b></p>
                                <p>
                                    def add_one(x):<br>
                                    &nbsp;&nbsp;return x + 1<br><br>
                                    uf = np.frompyfunc(add_one, 1, 1)<br>
                                    a = np.array([1, 2, 3, 4])<br>
                                    uf(a)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[2 3 4 5]</p>

                                <p><b>Very Important Notes:</b></p>
                                <ul>
                                    <li>Output ka dtype <b>object</b> hota hai</li>
                                    <li>C-level fast ufunc jaisa behave nahi karta</li>
                                    <li>Performance built-in ufunc se kam hoti hai</li>
                                </ul>

                                <hr>

                                <h3>Quick Comparison</h3>

                                <ul>
                                    <li><b>np.vectorize()</b> → easy, loop-based, not real ufunc</li>
                                    <li><b>np.frompyfunc()</b> → proper wrapper, dtype object</li>
                                    <li><b>Built-in ufunc</b> → fastest, C-level, best choice</li>
                                </ul>

                                <hr>

                                <h2>3. Array Reshaping and Manipulation</h2>
                                <hr>

                                <h3>3.1 reshape()</h3>

                                <p>
                                    reshape() array ka <b>shape change</b> karta hai,
                                    data change nahi hota.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>a.reshape(rows, columns)</p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, 3, 4, 5, 6])<br>
                                    a.reshape(2, 3)
                                </p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[1 2 3]<br>
                                    &nbsp;[4 5 6]]
                                </p>

                                <p><b>Golden Rule:</b></p>
                                <ul>
                                    <li>Total elements same rehne chahiye</li>
                                    <li>2 × 3 = 6 ✅ valid</li>
                                </ul>

                                <p><b>Invalid Example:</b></p>
                                <p>a.reshape(4, 2) ❌ (8 ≠ 6)</p>

                                <hr>

                                <h3>Auto reshape using -1</h3>

                                <p>
                                    -1 NumPy ko bolta hai:
                                    <b>baaki dimension khud calculate karo</b>.
                                </p>

                                <p><b>Examples:</b></p>
                                <p>
                                    a.reshape(3, -1)<br>
                                    a.reshape(-1, 3)
                                </p>

                                <hr>

                                <h3>Important Notes</h3>

                                <ul>
                                    <li>reshape() mostly <b>view</b> return karta hai</li>
                                    <li>1D ↔ 2D conversion ke liye use hota hai</li>
                                    <li>ML aur data preprocessing me widely used</li>
                                </ul>

                                <hr>

                                <h2>ravel() vs flatten()</h2>
                                <hr>

                                <p>
                                    Dono functions ka kaam multi-dimensional array ko
                                    <b>1D array</b> me convert karna hota hai.
                                </p>

                                <hr>

                                <h3>ravel()</h3>

                                <ul>
                                    <li>View return karta hai</li>
                                    <li>Memory share karta hai</li>
                                    <li>Fast hota hai</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2], [3, 4]])<br>
                                    b = a.ravel()<br>
                                    b[0] = 99
                                </p>

                                <p><b>Result:</b></p>
                                <p>
                                    a = [[99 2]<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;[3 4]]
                                </p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Performance important ho</li>
                                    <li>Memory bachani ho</li>
                                </ul>

                                <hr>

                                <h3>flatten()</h3>

                                <ul>
                                    <li>New copy banata hai</li>
                                    <li>Memory share nahi karta</li>
                                    <li>Thoda slow hota hai</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2], [3, 4]])<br>
                                    b = a.flatten()<br>
                                    b[0] = 99
                                </p>

                                <p><b>Result:</b></p>
                                <p>
                                    a = [[1 2]<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;[3 4]]
                                </p>

                                <hr>

                                <h3>Important Extra Points</h3>

                                <ul>
                                    <li>ravel() usually view deta hai, copy bhi ho sakti hai</li>
                                    <li>flatten() hamesha copy banata hai</li>
                                    <li>reshape(-1) ka behavior ravel() jaisa hota hai</li>
                                </ul>

                                <hr>

                                <h3>One-Line Memory Trick</h3>

                                <ul>
                                    <li>ravel() → view → fast → memory share</li>
                                    <li>flatten() → copy → safe → extra memory</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>np.expand_dims()</h2>
                                <hr>

                                <p>
                                    np.expand_dims() array me <b>ek naya dimension add</b> karta hai.
                                </p>

                                <p>
                                    Original data same rehta hai, sirf <b>shape change</b> hota hai.
                                </p>

                                <hr>

                                <h3>Syntax</h3>
                                <p>np.expand_dims(array, axis)</p>

                                <hr>

                                <h3>Example (1D → 2D)</h3>

                                <p>
                                    a = np.array([1, 2, 3])<br>
                                    a.shape → (3,)
                                </p>

                                <hr>

                                <h3>axis = 0 (Row Vector)</h3>

                                <p><b>Code:</b></p>
                                <p>np.expand_dims(a, axis=0)</p>

                                <p><b>Output:</b></p>
                                <p>[[1 2 3]]</p>

                                <p><b>Shape:</b></p>
                                <p>(1, 3)</p>

                                <hr>

                                <h3>axis = 1 (Column Vector)</h3>

                                <p><b>Code:</b></p>
                                <p>np.expand_dims(a, axis=1)</p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[1]<br>
                                    [2]<br>
                                    [3]]
                                </p>

                                <p><b>Shape:</b></p>
                                <p>(3, 1)</p>

                                <hr>

                                <h3>Important Notes</h3>

                                <ul>
                                    <li>expand_dims sirf <b>1 dimension</b> add karta hai</li>
                                    <li>axis decide karta hai naya dimension kaha add hoga</li>
                                    <li>reshape bhi ye kaam kar sakta hai, par expand_dims zyada readable hota hai</li>
                                </ul>

                                <hr>

                                <h3>Use Kab Kare?</h3>

                                <ul>
                                    <li>Machine Learning models me</li>
                                    <li>Broadcasting ke liye</li>
                                    <li>Matrix multiplication ke liye shape match karne me</li>
                                </ul>

                                <hr>

                                <h2>np.squeeze()</h2>
                                <hr>

                                <p>
                                    np.squeeze() array se <b>extra dimensions remove</b> karta hai.
                                </p>

                                <p>
                                    Sirf wahi dimensions remove hoti hain jinka <b>size = 1</b> hota hai.
                                </p>

                                <hr>

                                <h3>Example</h3>

                                <p>
                                    a = np.array([[[1, 2, 3]]])<br>
                                    a.shape → (1, 1, 3)
                                </p>

                                <p>
                                    b = np.squeeze(a)<br>
                                    b.shape → (3,)
                                </p>

                                <hr>

                                <h3>Axis ke saath squeeze</h3>

                                <p>
                                    Specific axis bhi remove ki ja sakti hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>np.squeeze(a, axis=0)</p>

                                <hr>

                                <h3>Important Rules</h3>

                                <ul>
                                    <li>squeeze size &gt; 1 wali dimension remove nahi kar sakta</li>
                                    <li>Wrong axis dene par error aata hai</li>
                                    <li>Data same rehta hai, sirf shape change hota hai</li>
                                </ul>

                                <hr>

                                <h3>expand_dims vs squeeze</h3>

                                <ul>
                                    <li>expand_dims → dimension add</li>
                                    <li>squeeze → dimension remove (size = 1)</li>
                                </ul>

                                <p><b>Shape Thinking Trick:</b></p>
                                <p>
                                    expand_dims → shape bada<br>
                                    squeeze → shape chhota
                                </p>

                                <hr>

                                <h2>3.2 Stacking and Splitting</h2>
                                <hr>

                                <p>
                                    Stacking ka matlab arrays ko <b>combine</b> karna hota hai,
                                    aur splitting ka matlab array ko <b>parts me divide</b> karna.
                                </p>

                                <hr>

                                <h3>Horizontal Stacking (hstack)</h3>

                                <p>
                                    Arrays ko <b>side by side</b> jodta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.hstack((a, b))</p>

                                <p><b>Example (1D):</b></p>
                                <p>
                                    a = np.array([1, 2, 3])<br>
                                    b = np.array([4, 5, 6])
                                </p>

                                <p><b>Output:</b></p>
                                <p>[1 2 3 4 5 6]</p>

                                <p><b>Note:</b></p>
                                <ul>
                                    <li>Columns badhte hain</li>
                                    <li>Rows same rehte hain</li>
                                </ul>

                                <hr>

                                <h3>2D Example (hstack)</h3>

                                <p>
                                    a = np.array([[1, 2],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3, 4]])<br>
                                    b = np.array([[5, 6],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[7, 8]])
                                </p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[1 2 5 6]<br>
                                    [3 4 7 8]]
                                </p>

                                <hr>

                                <h3>Vertical Stacking (vstack)</h3>

                                <p>
                                    Arrays ko <b>upar–niche</b> jodta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.vstack((a, b))</p>

                                <p><b>Example (1D):</b></p>
                                <p>
                                    a = np.array([1, 2, 3])<br>
                                    b = np.array([4, 5, 6])
                                </p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[1 2 3]<br>
                                    [4 5 6]]
                                </p>

                                <p><b>Note:</b></p>
                                <ul>
                                    <li>Rows badhte hain</li>
                                    <li>Columns same rehte hain</li>
                                </ul>

                                <hr>

                                <h3>concatenate()</h3>

                                <p>
                                    General-purpose stacking function hai,
                                    jo axis ka control deta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.concatenate((a, b), axis)</p>

                                <ul>
                                    <li>axis = 0 → vertical stacking</li>
                                    <li>axis = 1 → horizontal stacking</li>
                                </ul>

                                <hr>

                                <h3>Splitting Arrays</h3>

                                <p>
                                    Array ko <b>equal ya given parts</b> me todna splitting kehlata hai.
                                </p>

                                <hr>

                                <h3>hsplit() (Column-wise)</h3>

                                <p>
                                    Columns ko divide karta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2, 3, 4],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5, 6, 7, 8]])
                                </p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[[1 2]<br>
                                    &nbsp;[5 6]],<br><br>
                                    [[3 4]<br>
                                    &nbsp;[7 8]]]
                                </p>

                                <hr>

                                <h3>vsplit() (Row-wise)</h3>

                                <p>
                                    Rows ko divide karta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3, 4],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5, 6],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[7, 8]])
                                </p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[[1 2]<br>
                                    &nbsp;[3 4]],<br><br>
                                    [[5 6]<br>
                                    &nbsp;[7 8]]]
                                </p>

                                <hr>

                                <h3>Important Rules</h3>

                                <ul>
                                    <li>Equal split possible hona chahiye, warna error aayega</li>
                                    <li>Split ka output <b>list of arrays</b> hota hai</li>
                                    <li>hsplit → columns todta hai</li>
                                    <li>vsplit → rows todta hai</li>
                                </ul>

                                <hr>

                                <h3>One-line Memory Tricks</h3>

                                <ul>
                                    <li>hstack → side by side</li>
                                    <li>vstack → up-down</li>
                                    <li>hsplit → columns todna</li>
                                    <li>vsplit → rows todna</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>3.3 Copy vs View (Very Important)</h2>
                                <hr>

                                <p>
                                    NumPy me array ke saath kaam karte waqt
                                    <b>copy aur view ka concept</b> memory aur performance dono ko affect karta hai.
                                </p>

                                <hr>

                                <h3>.copy() (Deep Copy)</h3>

                                <p>
                                    .copy() ek <b>naya independent array</b> banata hai.
                                </p>

                                <ul>
                                    <li>Original array se memory share nahi karta</li>
                                    <li>Changes original array me reflect nahi hote</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, 3, 4])<br>
                                    b = a.copy()<br><br>
                                    b[0] = 99
                                </p>

                                <p><b>Result:</b></p>
                                <p>
                                    a → [1 2 3 4]<br>
                                    b → [99 2 3 4]
                                </p>

                                <p><b>Properties:</b></p>
                                <ul>
                                    <li>Alag memory space</li>
                                    <li>View ke comparison me slow</li>
                                    <li>Safe (no side effects)</li>
                                </ul>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Original data protect karna ho</li>
                                    <li>Unexpected modification avoid karni ho</li>
                                </ul>

                                <hr>

                                <h3>.view() (Shallow Copy / View)</h3>

                                <p>
                                    .view() original array ka <b>view</b> banata hai
                                    aur memory <b>share</b> karta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, 3, 4])<br>
                                    b = a.view()<br><br>
                                    b[0] = 99
                                </p>

                                <p><b>Result:</b></p>
                                <p>
                                    a → [99 2 3 4]<br>
                                    b → [99 2 3 4]
                                </p>

                                <p><b>Properties:</b></p>
                                <ul>
                                    <li>Same memory share hoti hai</li>
                                    <li>Fast hota hai</li>
                                    <li>Risky agar unaware ho</li>
                                </ul>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Performance important ho</li>
                                    <li>Large data ke saath kaam ho</li>
                                </ul>

                                <hr>

                                <h3>Memory Sharing Summary</h3>

                                <ul>
                                    <li>copy() → no memory sharing → safe</li>
                                    <li>view() → memory sharing → fast but risky</li>
                                </ul>

                                <hr>

                                <h3>Very Important Notes (Exam + Interview)</h3>

                                <ul>
                                    <li>Slicing (a[1:4]) usually <b>view</b> return karta hai</li>
                                    <li>reshape(), ravel() aksar <b>view</b> dete hain</li>
                                    <li>flatten(), copy() hamesha <b>copy</b> dete hain</li>
                                </ul>

                                <hr>

                                <h2>4. Broadcasting (Intermediate)</h2>
                                <hr>

                                <p>
                                    Broadcasting NumPy ka ek <b>powerful feature</b> hai
                                    jo different shapes ke arrays par arithmetic operations allow karta hai.
                                </p>

                                <p>
                                    Isme <b>extra memory allocate nahi hoti</b>.
                                </p>

                                <hr>

                                <h3>Simple Definition</h3>

                                <p>
                                    Broadcasting me NumPy small array ko logically
                                    <b>bade array ke shape me expand</b> karta hai
                                    bina data copy kiye.
                                </p>

                                <hr>

                                <h3>Example 1: Scalar Broadcasting</h3>

                                <p>
                                    a = np.array([1, 2, 3])<br>
                                    a + 10
                                </p>

                                <p><b>Output:</b></p>
                                <p>[11 12 13]</p>

                                <p>
                                    Scalar value har element ke saath apply ho gayi.
                                </p>

                                <hr>

                                <h3>Example 2: Array Broadcasting</h3>

                                <p>
                                    a = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]])<br><br>
                                    b = np.array([10, 20, 30])
                                </p>

                                <p>a + b</p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[11 22 33]<br>
                                    [14 25 36]]
                                </p>

                                <p>
                                    b ko har row ke saath broadcast kiya gaya.
                                </p>

                                <hr>

                                <h3>Broadcasting Rules (Very Important)</h3>

                                <ul>
                                    <li>Dimensions ko <b>right se compare</b> kiya jata hai</li>
                                    <li>Dono equal ho ya kisi ek ki value = 1 ho</li>
                                    <li>Nahi to <b>ERROR</b> aata hai</li>
                                </ul>

                                <hr>

                                <h3>Valid Broadcasting</h3>

                                <ul>
                                    <li>(2,3) + (3,) → valid</li>
                                    <li>(3,1) + (1,4) → valid</li>
                                </ul>

                                <hr>

                                <h3>Invalid Broadcasting</h3>

                                <ul>
                                    <li>(2,3) + (2,2) → invalid</li>
                                    <li>(3,3) + (2,) → invalid</li>
                                </ul>

                                <hr>

                                <h3>Broadcasting + View (Important Warning)</h3>

                                <p>
                                    Broadcasting internally <b>views</b> ka use karta hai.
                                </p>

                                <p>
                                    Agar view ke through data modify kiya gaya,
                                    to original array change ho sakta hai.
                                </p>

                                <p><b>Best Practice:</b></p>
                                <ul>
                                    <li>Read-only operations → view OK</li>
                                    <li>Write operations → copy safer</li>
                                </ul>

                                <hr>

                                <h3>One-line Memory Tricks</h3>

                                <ul>
                                    <li>copy() → safe but slow</li>
                                    <li>view() → fast but risky</li>
                                    <li>Broadcasting → shape expand, no extra memory</li>
                                </ul>

                                <hr>

                                <h3>Quick Broadcasting Checklist (Exam Gold)</h3>

                                <ul>
                                    <li>Shapes right se compare karo</li>
                                    <li>Same ho ya ek = 1 ho → OK</li>
                                    <li>Nahi to → ERROR</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>4.2 Applying Broadcasting</h2>
                                <hr>

                                <p>
                                    Broadcasting ka use karke hum <b>different shapes</b> ke arrays par
                                    <b>bina loop ke operations</b> kar sakte hain.
                                </p>

                                <hr>

                                <h3>1) Adding Scalar to Array</h3>

                                <p>Scalar value har element ke saath automatically apply hoti hai.</p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, 3])<br>
                                    b = 10<br><br>
                                    a + b
                                </p>

                                <p><b>Output:</b></p>
                                <p>[11 12 13]</p>

                                <p><b>Explanation:</b></p>
                                <ul>
                                    <li>Scalar ka shape = ()</li>
                                    <li>Har element ke saath broadcast ho gaya</li>
                                </ul>

                                <hr>

                                <h3>2) Adding Vector to Matrix (Row-wise)</h3>

                                <p>
                                    Vector ko matrix ki <b>har row</b> ke saath add kiya jata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    matrix = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]])<br><br>
                                    vector = np.array([10, 20, 30])
                                </p>

                                <p>matrix + vector</p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[11 22 33]<br>
                                    [14 25 36]]
                                </p>

                                <p><b>Explanation:</b></p>
                                <ul>
                                    <li>vector ko treat kiya gaya as (1,3)</li>
                                    <li>Har row ke saath broadcast hua</li>
                                </ul>

                                <hr>

                                <h3>3) Adding Vector to Matrix (Column-wise)</h3>

                                <p>
                                    Vector ko <b>har column</b> ke saath add karna.
                                </p>

                                <p><b>Wrong Example:</b></p>
                                <p>
                                    vector = np.array([10, 20])<br>
                                    matrix + vector ❌ ERROR
                                </p>

                                <p><b>Correct Way:</b></p>
                                <p>
                                    vector = vector.reshape(2, 1)<br>
                                    matrix + vector
                                </p>

                                <p><b>Output:</b></p>
                                <p>
                                    [[11 12 13]<br>
                                    [24 25 26]]
                                </p>

                                <p><b>Explanation:</b></p>
                                <ul>
                                    <li>(2,1) ko columns me stretch kiya gaya</li>
                                </ul>

                                <hr>

                                <h3>4) Real Data Usage (Practical Examples)</h3>

                                <h4>a) Data Centering (Mean Subtraction)</h4>

                                <p>Har column se mean subtract karna.</p>

                                <p>
                                    mean = np.mean(data, axis=0)<br>
                                    data - mean
                                </p>

                                <hr>

                                <h4>b) Image Processing (Brightness Increase)</h4>

                                <p>
                                    Image array me brightness add karna.
                                </p>

                                <p>
                                    image + 20<br>
                                    Har pixel bright ho jata hai
                                </p>

                                <hr>

                                <h4>c) Applying Masks</h4>

                                <p>
                                    Condition ke saath broadcasted operation.
                                </p>

                                <p>
                                    data[data &gt; 20] += 5
                                </p>

                                <p><b>Output:</b></p>
                                <p>[10 20 35 45]</p>

                                <hr>

                                <h3>Important Notes</h3>

                                <ul>
                                    <li>Broadcasting loop ka replacement hai</li>
                                    <li>Code fast aur clean ho jata hai</li>
                                    <li>Shape mismatch hua to error aayega</li>
                                    <li>reshape() aur expand_dims() se control hota hai</li>
                                </ul>

                                <hr>

                                <p><b>Memory Trick:</b><br>
                                    Broadcasting = "Ek value → sab jagah automatically"
                                </p>

                                <hr>
                                <hr>

                                <h2>5. Mathematical and Statistical Functions</h2>
                                <hr>

                                <p>
                                    NumPy statistical functions data analysis, ML preprocessing
                                    aur feature engineering me extensively use hote hain.
                                </p>

                                <hr>

                                <h3>1) sum</h3>
                                <p>Array ke sabhi elements ka total sum.</p>

                                <p>np.sum(array, axis=None)</p>

                                <hr>

                                <h3>2) mean</h3>
                                <p>Average (mean) nikalta hai.</p>

                                <p>
                                    Note: Mean outliers se affect hota hai.
                                </p>

                                <hr>

                                <h3>3) median</h3>
                                <p>Middle value (sorted data ke baad).</p>

                                <p>
                                    Median outliers se <b>kam affect</b> hota hai.
                                </p>

                                <hr>

                                <h3>4) std (Standard Deviation)</h3>
                                <p>Data ka spread batata hai.</p>

                                <ul>
                                    <li>Default: population std (ddof = 0)</li>
                                    <li>Sample std: ddof = 1</li>
                                </ul>

                                <hr>

                                <h3>5) var (Variance)</h3>
                                <p>Standard deviation ka square.</p>

                                <p>
                                    variance = (standard deviation)<sup>2</sup>
                                </p>

                                <hr>

                                <h3>6) min / max</h3>
                                <p>Minimum aur maximum value nikalta hai.</p>

                                <hr>

                                <h3>7) argmin / argmax</h3>
                                <p>
                                    Value ka <b>index</b> return karta hai (value nahi).
                                </p>

                                <hr>

                                <h3>8) percentile</h3>
                                <p>
                                    Data distribution samajhne ke liye.
                                </p>

                                <ul>
                                    <li>50th percentile = median</li>
                                    <li>Use: Quartiles, IQR, outlier detection</li>
                                </ul>

                                <hr>

                                <h3>9) Correlation</h3>
                                <p>
                                    Do variables ka relationship measure karta hai.<br>
                                    Range: -1 to +1
                                </p>

                                <hr>

                                <h3>10) Covariance</h3>
                                <p>
                                    Variables ka joint variability batata hai.
                                </p>

                                <ul>
                                    <li>Diagonal → variance</li>
                                    <li>Off-diagonal → covariance</li>
                                </ul>

                                <hr>

                                <h3>11) Cumulative Functions</h3>

                                <h4>cumsum</h4>
                                <p>Running total nikalta hai.</p>

                                <h4>cumprod</h4>
                                <p>Running product nikalta hai.</p>

                                <hr>

                                <h3>Quick Summary (Exam Gold)</h3>

                                <ul>
                                    <li>sum → total</li>
                                    <li>mean → average</li>
                                    <li>median → middle value</li>
                                    <li>std → spread</li>
                                    <li>var → spread²</li>
                                    <li>min / max → extreme values</li>
                                    <li>argmin / argmax → index</li>
                                    <li>percentile → distribution position</li>
                                    <li>corrcoef → relationship</li>
                                    <li>cov → joint variability</li>
                                    <li>cumsum → running total</li>
                                    <li>cumprod → running product</li>
                                </ul>

                                <hr>
                                <hr>
                                <h2>6. NumPy Random Module</h2>
                                <hr>

                                <p>
                                    NumPy ka random module <b>random numbers generate</b> karne ke liye use hota hai.
                                </p>

                                <p><b>Use cases:</b></p>
                                <ul>
                                    <li>Simulations</li>
                                    <li>Machine Learning</li>
                                    <li>Testing / Dummy data</li>
                                    <li>Games / Experiments</li>
                                </ul>

                                <hr>

                                <h2>6.1 Basic Random Functions</h2>
                                <hr>

                                <h3>np.random.rand()</h3>

                                <p>
                                    Uniform distribution se random <b>float numbers (0 to 1)</b> generate karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.random.rand(d0, d1, ..., dn)</p>

                                <p><b>Example:</b></p>
                                <p>np.random.rand(3)</p>

                                <p><b>Important:</b></p>
                                <ul>
                                    <li>Range hamesha [0, 1) hota hai</li>
                                </ul>

                                <hr>

                                <h3>np.random.randn()</h3>

                                <p>
                                    Standard Normal Distribution se random numbers generate karta hai.
                                </p>

                                <ul>
                                    <li>Mean = 0</li>
                                    <li>Standard Deviation = 1</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>np.random.randn(3)</p>

                                <p><b>Important:</b></p>
                                <ul>
                                    <li>Values negative bhi ho sakti hain</li>
                                    <li>ML aur statistics me widely use hota hai</li>
                                </ul>

                                <hr>

                                <h3>rand vs randn</h3>

                                <ul>
                                    <li>rand → uniform distribution (0 to 1)</li>
                                    <li>randn → normal distribution (mean 0, std 1)</li>
                                </ul>

                                <hr>

                                <h3>np.random.randint()</h3>

                                <p>
                                    Given range me <b>random integers</b> generate karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.random.randint(low, high, size)</p>

                                <p><b>Important:</b></p>
                                <ul>
                                    <li>low included</li>
                                    <li>high excluded</li>
                                </ul>

                                <hr>

                                <h3>np.random.choice()</h3>

                                <p>
                                    Given array se random elements select karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.random.choice(a, size, replace=True, p=None)</p>

                                <p><b>Weighted Random:</b></p>
                                <ul>
                                    <li>Probability zyada → selection chance zyada</li>
                                    <li>All probabilities ka sum = 1 hona chahiye</li>
                                </ul>

                                <hr>

                                <h3>np.random.seed()</h3>

                                <p>
                                    Random numbers ko <b>reproducible</b> banata hai.
                                </p>

                                <p><b>Use kab kare:</b></p>
                                <ul>
                                    <li>Debugging</li>
                                    <li>ML experiments</li>
                                    <li>Exams / Testing</li>
                                </ul>

                                <hr>

                                <h3>np.random.shuffle() vs np.random.permutation()</h3>

                                <ul>
                                    <li>shuffle → original array change hota hai</li>
                                    <li>permutation → shuffled copy return karta hai</li>
                                </ul>

                                <hr>

                                <h3>Quick Summary</h3>

                                <ul>
                                    <li>rand → random floats (0–1)</li>
                                    <li>randn → normal distribution</li>
                                    <li>randint → random integers</li>
                                    <li>choice → random selection</li>
                                    <li>seed → reproducibility</li>
                                    <li>shuffle → in-place shuffle</li>
                                    <li>permutation → safe shuffled copy</li>
                                </ul>

                                <hr>

                                <hr>
                                <h2>6.2 Random Distributions (NumPy)</h2>
                                <hr>

                                <p>
                                    Random distributions ka use <b>real-world randomness</b> ko model karne ke liye hota
                                    hai.
                                    Ye Machine Learning, Statistics, Probability aur Simulations me daily use hote hain.
                                </p>

                                <hr>
                                <h3>Uniform Distribution</h3>

                                <p>
                                    Har value ka chance <b>equal</b> hota hai.
                                </p>

                                <p><b>Function:</b></p>
                                <pre>np.random.uniform(low, high, size)</pre>

                                <p><b>Example:</b></p>
                                <pre>
np.random.uniform(0, 10, 5)
</pre>

                                <p><b>Use Cases:</b></p>
                                <ul>
                                    <li>Random sampling</li>
                                    <li>Noise generation</li>
                                    <li>Fair random values</li>
                                </ul>

                                <hr>
                                <h3>Normal Distribution (Gaussian)</h3>

                                <p>
                                    Bell-shaped curve hoti hai jisme values
                                    <b>mean ke aas-paas zyada</b> hoti hain.
                                </p>

                                <p><b>Function:</b></p>
                                <pre>np.random.normal(loc, scale, size)</pre>

                                <p><b>Parameters:</b></p>
                                <ul>
                                    <li><b>loc</b> → mean</li>
                                    <li><b>scale</b> → standard deviation</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <pre>
np.random.normal(0, 1, 5)
</pre>

                                <p><b>Use Cases:</b></p>
                                <ul>
                                    <li>Measurement errors</li>
                                    <li>Natural phenomena</li>
                                    <li>ML weight initialization</li>
                                </ul>

                                <hr>
                                <h3>Binomial Distribution</h3>

                                <p>
                                    Fixed number of trials (n) aur
                                    success probability (p) par based hota hai.
                                </p>

                                <p><b>Function:</b></p>
                                <pre>np.random.binomial(n, p, size)</pre>

                                <p><b>Example:</b></p>
                                <pre>
np.random.binomial(10, 0.5, 5)
</pre>

                                <p><b>Meaning:</b></p>
                                <ul>
                                    <li>10 coin tosses</li>
                                    <li>Head probability = 0.5</li>
                                </ul>

                                <p><b>Use Cases:</b></p>
                                <ul>
                                    <li>Yes / No experiments</li>
                                    <li>Bernoulli trials</li>
                                    <li>A/B testing</li>
                                </ul>

                                <hr>
                                <h3>Poisson Distribution</h3>

                                <p>
                                    Fixed time ya space me
                                    <b>event count</b> ko model karta hai.
                                </p>

                                <p><b>Function:</b></p>
                                <pre>np.random.poisson(lam, size)</pre>

                                <p>
                                    <b>lam (λ)</b> → average rate (events per interval)
                                </p>

                                <p><b>Example:</b></p>
                                <pre>
np.random.poisson(3, 5)
</pre>

                                <p><b>Use Cases:</b></p>
                                <ul>
                                    <li>Call arrivals</li>
                                    <li>Website hits</li>
                                    <li>Accident count</li>
                                </ul>

                                <hr>
                                <h3>Logistic Distribution</h3>

                                <p>
                                    Normal distribution jaisa hota hai,
                                    lekin <b>tails thodi heavy</b> hoti hain.
                                </p>

                                <p><b>Function:</b></p>
                                <pre>np.random.logistic(loc, scale, size)</pre>

                                <p><b>Example:</b></p>
                                <pre>
np.random.logistic(0, 1, 5)
</pre>

                                <p><b>Use Cases:</b></p>
                                <ul>
                                    <li>Logistic regression</li>
                                    <li>Growth models</li>
                                </ul>

                                <hr>
                                <h3>Exponential Distribution</h3>

                                <p>
                                    Events ke beech ka <b>waiting time</b> model karta hai.
                                </p>

                                <p><b>Function:</b></p>
                                <pre>np.random.exponential(scale, size)</pre>

                                <p><b>Example:</b></p>
                                <pre>
np.random.exponential(1, 5)
</pre>

                                <p><b>Use Cases:</b></p>
                                <ul>
                                    <li>Waiting time</li>
                                    <li>Failure time</li>
                                    <li>Queue systems</li>
                                </ul>

                                <hr>
                                <h3>Important Notes (Exam + Practice)</h3>
                                <ul>
                                    <li>
                                        <b>scale ≠ std</b> hamesha nahi hota
                                        <br>Exponential distribution me scale = mean
                                    </li>
                                    <li>
                                        <b>lam (Poisson)</b> = average number of events
                                    </li>
                                    <li>
                                        <b>Normal vs Uniform:</b>
                                        <ul>
                                            <li>Uniform → equal chance</li>
                                            <li>Normal → mean-centered</li>
                                        </ul>
                                    </li>
                                </ul>

                                <hr>
                                <h3>Quick Comparison (Exam Gold)</h3>
                                <ul>
                                    <li>Uniform → equal probability</li>
                                    <li>Normal → bell curve</li>
                                    <li>Binomial → fixed trials</li>
                                    <li>Poisson → event count</li>
                                    <li>Exponential → waiting time</li>
                                    <li>Logistic → heavy tails</li>
                                </ul>

                                <hr>
                                <h3>One-line Memory Trick</h3>
                                <p>
                                    <b>Distributions =</b><br>
                                    "Real world randomness ka mathematical model"
                                </p>

                                <hr>

                                <hr>
                                <h2>6.3 Shuffling and Sampling (NumPy)</h2>
                                <hr>

                                <p>
                                    Shuffling aur sampling ka use data ko <b>randomize</b> karne,
                                    train/test split banane, bias kam karne
                                    aur ML experiments me hota hai.
                                </p>

                                <hr>
                                <h3>np.random.shuffle()</h3>

                                <p>
                                    Array ko <b>in-place shuffle</b> karta hai,
                                    matlab original array <b>change ho jata hai</b>.
                                </p>

                                <p><b>Syntax:</b></p>
                                <pre>np.random.shuffle(x)</pre>

                                <p><b>Example:</b></p>
                                <pre>
a = np.array([1, 2, 3, 4, 5])
np.random.shuffle(a)

print(a)
# Output: [3 1 5 2 4]  (random order)
</pre>

                                <h4>Important Points</h4>
                                <ul>
                                    <li>Return kuch nahi karta (None)</li>
                                    <li>Sirf existing array ko modify karta hai</li>
                                    <li>Memory efficient, but risky agar original data chahiye</li>
                                </ul>

                                <h4>Use kab kare?</h4>
                                <ul>
                                    <li>Jab original order ki zarurat na ho</li>
                                </ul>

                                <hr>
                                <h3>np.random.permutation()</h3>

                                <p>
                                    Array ka <b>shuffled copy</b> banata hai,
                                    original array <b>unchanged</b> rehta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <pre>np.random.permutation(x)</pre>

                                <p><b>Example:</b></p>
                                <pre>
a = np.array([1, 2, 3, 4, 5])
b = np.random.permutation(a)

print(a)  # [1 2 3 4 5]
print(b)  # [3 1 5 2 4]
</pre>

                                <h4>Important Points</h4>
                                <ul>
                                    <li>New array return hota hai</li>
                                    <li>Original data safe rehta hai</li>
                                </ul>

                                <h4>Use kab kare?</h4>
                                <ul>
                                    <li>Jab original data preserve karna ho</li>
                                </ul>

                                <hr>
                                <h3>shuffle vs permutation (Difference)</h3>

                                <ul>
                                    <li><b>shuffle()</b> → in-place → original change</li>
                                    <li><b>permutation()</b> → copy → original safe</li>
                                </ul>

                                <hr>
                                <h3>Sampling using np.random.choice()</h3>

                                <p>
                                    Random <b>sample select</b> karne ke liye use hota hai.
                                    Ye shuffling se different hota hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <pre>np.random.choice(a, size, replace=True, p=None)</pre>

                                <p><b>Example:</b></p>
                                <pre>
a = [10, 20, 30, 40]
np.random.choice(a, 2)
</pre>

                                <h4>Without Replacement (Sampling)</h4>
                                <pre>
np.random.choice(a, 2, replace=False)
</pre>
                                <p>Same element repeat nahi hoga</p>

                                <h4>With Probabilities (Weighted Sampling)</h4>
                                <pre>
np.random.choice(a, 2, p=[0.1, 0.2, 0.3, 0.4])
</pre>

                                <hr>
                                <h3>Random Seed (Reproducibility)</h3>

                                <p>
                                    np.random.seed() random output ko <b>fixed</b> bana deta hai.
                                    <br>Same seed ⇒ same random numbers
                                </p>

                                <p><b>Syntax:</b></p>
                                <pre>np.random.seed(seed_value)</pre>

                                <p><b>Example:</b></p>
                                <pre>
np.random.seed(42)
np.random.rand(3)

# Output (har baar same):
# [0.37454012 0.95071431 0.73199394]
</pre>

                                <h4>Use kab kare?</h4>
                                <ul>
                                    <li>Debugging</li>
                                    <li>ML experiments</li>
                                    <li>Exams / Testing</li>
                                </ul>

                                <hr>
                                <h3>Important Notes (Exam + Real Code)</h3>
                                <ul>
                                    <li>
                                        shuffle() axis-wise shuffle support nahi karta
                                        <br>(poora array shuffle hota hai)
                                    </li>
                                    <li>
                                        permutation() numbers ka range bhi le sakta hai
                                        <br><code>np.random.permutation(5) → [3 1 4 0 2]</code>
                                    </li>
                                    <li>
                                        choice() = sampling
                                        <br>shuffle / permutation() = reordering
                                    </li>
                                </ul>

                                <hr>
                                <h3>Quick Summary (Exam Gold)</h3>
                                <ul>
                                    <li>shuffle → in-place random order</li>
                                    <li>permutation → shuffled copy</li>
                                    <li>choice → random sample</li>
                                    <li>seed → reproducible result</li>
                                </ul>

                                <hr>
                                <h3>One-line Memory Trick</h3>
                                <p>
                                    <b>shuffle</b> = change original<br>
                                    <b>permutation</b> = safe copy<br>
                                    <b>seed</b> = same output
                                </p>

                                <hr>
                                <h2>7. Advanced NumPy (Performance and Memory)</h2>
                                <hr>

                                <p>
                                    Advanced NumPy ka focus hota hai:
                                </p>

                                <ul>
                                    <li>Speed increase karna</li>
                                    <li>Memory optimize karna</li>
                                    <li>Large datasets efficiently handle karna</li>
                                </ul>

                                <hr>

                                <h2>7.1 Vectorization</h2>
                                <hr>

                                <p>
                                    Vectorization ka matlab hai:
                                    <b>Python loops avoid karke direct array operations use karna</b>.
                                </p>

                                <hr>

                                <h3>Why Python loops are slow?</h3>

                                <ul>
                                    <li>Python loops interpreted hote hain</li>
                                    <li>Har iteration me overhead hota hai</li>
                                    <li>Memory access inefficient hota hai</li>
                                </ul>

                                <p>
                                    NumPy internally <b>C language</b> me likha hota hai,
                                    isliye vectorized operations C-level pe run hote hain.
                                </p>

                                <hr>

                                <h3>Loop vs Vectorized Code</h3>

                                <p><b>Loop (slow):</b></p>
                                <p>
                                    for i in range(len(a)):<br>
                                    &nbsp;&nbsp;b[i] = a[i] * 2
                                </p>

                                <p><b>Vectorized (fast):</b></p>
                                <p>
                                    b = a * 2
                                </p>

                                <hr>

                                <h3>Performance Example</h3>

                                <p>
                                    a = np.random.rand(1_000_000)
                                </p>

                                <p><b>Loop:</b></p>
                                <p>
                                    b = np.zeros_like(a)<br>
                                    for i in range(len(a)):<br>
                                    &nbsp;&nbsp;b[i] = a[i] ** 2
                                </p>

                                <p><b>Vectorized:</b></p>
                                <p>
                                    b = a ** 2
                                </p>

                                <hr>

                                <h3>Result</h3>

                                <ul>
                                    <li>Vectorized code generally <b>10–100x faster</b> hota hai</li>
                                    <li>Code short, readable aur safer hota hai</li>
                                </ul>

                                <hr>

                                <h3>Best Practice</h3>

                                <ul>
                                    <li>❌ for-loops over NumPy arrays</li>
                                    <li>✅ Vectorized expressions</li>
                                </ul>

                                <hr>

                                <h2>7.2 Broadcasting Optimization</h2>
                                <hr>

                                <p>
                                    Broadcasting memory-efficient hota hai
                                    aur temporary arrays banaye bina operations ho jate hain.
                                </p>

                                <hr>

                                <h3>Avoid loops using broadcasting</h3>

                                <p><b>Example:</b></p>
                                <p>
                                    matrix = np.random.rand(1000, 1000)<br>
                                    vector = np.random.rand(1000)<br><br>
                                    result = matrix + vector[:, np.newaxis]
                                </p>

                                <ul>
                                    <li>Vector column-wise broadcast hua</li>
                                    <li>No explicit loop</li>
                                    <li>No extra memory</li>
                                </ul>

                                <hr>

                                <h3>Why Broadcasting is Efficient?</h3>

                                <ul>
                                    <li>No data copy</li>
                                    <li>Views internally use hote hain</li>
                                    <li>CPU cache friendly</li>
                                </ul>

                                <hr>

                                <h3>Optimization Tips</h3>

                                <ul>
                                    <li>Loops ke jagah broadcasting use karo</li>
                                    <li>Repeated calculations avoid karo</li>
                                    <li>Intermediate results cache karo</li>
                                </ul>

                                <hr>

                                <h2>7.3 Memory Layout (Very Important)</h2>
                                <hr>

                                <p>
                                    Memory layout performance ko directly affect karta hai.
                                </p>

                                <hr>

                                <h3>C-order vs F-order</h3>

                                <p><b>C-order (Row-major):</b></p>
                                <ul>
                                    <li>Rows contiguous hoti hain</li>
                                    <li>NumPy default</li>
                                    <li>Python-style</li>
                                </ul>

                                <p><b>F-order (Column-major):</b></p>
                                <ul>
                                    <li>Columns contiguous hoti hain</li>
                                    <li>MATLAB / Fortran-style</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1,2,3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,5,6]], order='C')
                                </p>

                                <hr>

                                <h3>Strides</h3>

                                <p>
                                    Strides batate hain:
                                    next element tak pahunchne ke liye
                                    <b>kitne bytes skip</b> karne padenge.
                                </p>

                                <p><b>Example:</b></p>
                                <p>a.strides</p>

                                <p>
                                    Output format:<br>
                                    (bytes_per_row, bytes_per_column)
                                </p>

                                <hr>

                                <h3>Contiguous Memory Advantage</h3>

                                <ul>
                                    <li>Faster memory access</li>
                                    <li>Better CPU cache usage</li>
                                </ul>

                                <p><b>Convert to contiguous:</b></p>
                                <p>np.ascontiguousarray(a)</p>

                                <hr>

                                <h3>Important Note</h3>

                                <p>
                                    Slicing aur transpose ke baad array
                                    aksar <b>non-contiguous</b> ho jata hai.
                                </p>

                                <hr>

                                <h2>7.4 Advanced Indexing</h2>
                                <hr>

                                <p>
                                    Advanced indexing complex data selection ke liye use hoti hai.
                                </p>

                                <hr>

                                <h3>Integer Indexing</h3>

                                <p>
                                    a = np.array([10, 20, 30, 40])<br>
                                    indices = np.array([0, 2, 3])<br><br>
                                    a[indices]
                                </p>

                                <p><b>Output:</b></p>
                                <p>[10 30 40]</p>

                                <hr>

                                <h3>Multi-dimensional Fancy Indexing</h3>

                                <p>
                                    a = np.array([[1,2,3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,5,6],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[7,8,9]])<br><br>
                                    rows = np.array([0, 2])<br>
                                    cols = np.array([1, 2])<br><br>
                                    a[rows, cols]
                                </p>

                                <p><b>Output:</b></p>
                                <p>[2 9]</p>

                                <hr>

                                <h3>Mask (Boolean) Indexing</h3>

                                <p>
                                    a = np.array([1, 2, 3, 4, 5])<br>
                                    mask = a &gt; 2<br><br>
                                    a[mask]
                                </p>

                                <p><b>Output:</b></p>
                                <p>[3 4 5]</p>

                                <hr>

                                <h3>Pattern Extraction Examples</h3>

                                <ul>
                                    <li>Even numbers: a[a % 2 == 0]</li>
                                    <li>Range filtering: a[(a &gt;= 10) &amp; (a &lt;= 50)]</li>
                                </ul>

                                <hr>

                                <h3>Performance Rules (Exam + Real Code)</h3>

                                <ul>
                                    <li>Vectorize everything possible</li>
                                    <li>Avoid Python loops</li>
                                    <li>Use broadcasting smartly</li>
                                    <li>Prefer contiguous arrays</li>
                                    <li>Masking &gt; manual filtering</li>
                                </ul>

                                <hr>

                                <h3>One-Line Memory Trick</h3>

                                <p>
                                    Fast NumPy =<br>
                                    <b>Vectorization + Broadcasting + Contiguous Memory</b>
                                </p>

                                <hr>
                                <hr>
                                <h2>8. File Handling in NumPy</h2>
                                <hr>

                                <p>
                                    NumPy arrays ko disk par <b>save</b> aur wapas <b>load</b>
                                    karne ke liye built-in functions deta hai.
                                </p>

                                <p>
                                    Ye data persistence, reuse aur sharing ke liye useful hai.
                                </p>

                                <hr>

                                <h2>8.1 Saving and Loading Arrays</h2>
                                <hr>

                                <h3>np.save() ( .npy format )</h3>

                                <p>
                                    Single NumPy array ko <b>binary format (.npy)</b> me save karta hai.
                                </p>

                                <ul>
                                    <li>Fast hota hai</li>
                                    <li>Data type aur shape preserve karta hai</li>
                                </ul>

                                <p><b>Syntax:</b></p>
                                <p>np.save(filename, array)</p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, 3, 4])<br>
                                    np.save('my_array.npy', a)
                                </p>

                                <p>File banegi: <b>my_array.npy</b></p>

                                <hr>

                                <h3>np.load()</h3>

                                <p>
                                    .npy file se array load karta hai.
                                </p>

                                <p><b>Syntax:</b></p>
                                <p>np.load(filename)</p>

                                <p><b>Example:</b></p>
                                <p>
                                    b = np.load('my_array.npy')<br>
                                    print(b)
                                </p>

                                <p><b>Output:</b></p>
                                <p>[1 2 3 4]</p>

                                <hr>

                                <h3>Important Notes</h3>

                                <ul>
                                    <li>.npy → NumPy specific aur fastest</li>
                                    <li>dtype aur shape exactly same rehta hai</li>
                                    <li>Large numerical data ke liye best option</li>
                                </ul>

                                <hr>

                                <h3>np.savetxt() (Text / CSV)</h3>

                                <p>
                                    Array ko <b>text / CSV file</b> me save karta hai.
                                </p>

                                <ul>
                                    <li>Human-readable hota hai</li>
                                    <li>Binary ke comparison me slow hota hai</li>
                                </ul>

                                <p><b>Syntax:</b></p>
                                <p>np.savetxt(fname, array, delimiter=' ')</p>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([[1, 2, 3],<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4, 5, 6]])<br><br>
                                    np.savetxt('data.csv', a, delimiter=',')
                                </p>

                                <hr>

                                <h3>np.loadtxt()</h3>

                                <p>
                                    Text / CSV file se numerical data load karta hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    b = np.loadtxt('data.csv', delimiter=',')<br>
                                    print(b)
                                </p>

                                <hr>

                                <h3>Limitations</h3>

                                <ul>
                                    <li>Large files ke liye slow</li>
                                    <li>Mixed data (string + number) me problem hoti hai</li>
                                </ul>

                                <hr>

                                <h2>8.2 Working with CSV Files</h2>
                                <hr>

                                <h3>Reading CSV</h3>

                                <p>
                                    Simple numerical CSV ke liye <b>np.loadtxt()</b> use hota hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    data = np.loadtxt('file.csv', delimiter=',', skiprows=1)
                                </p>

                                <hr>

                                <h3>Handling Missing / Mixed Data</h3>

                                <p>
                                    <b>np.genfromtxt()</b> zyada powerful hota hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    data = np.genfromtxt('mixed.csv',<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;delimiter=',',<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;dtype=None,<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;encoding=None)
                                </p>

                                <hr>

                                <h3>Why genfromtxt is better?</h3>

                                <ul>
                                    <li>Missing values handle karta hai</li>
                                    <li>Mixed data support karta hai</li>
                                    <li>Flexible parsing deta hai</li>
                                </ul>

                                <hr>

                                <h3>Saving Multiple Arrays Together</h3>

                                <p>
                                    Multiple arrays ko ek file me save karne ke liye <b>np.savez()</b> use hota hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    np.savez('data.npz', a=a, b=b)
                                </p>

                                <p><b>Load:</b></p>
                                <p>
                                    data = np.load('data.npz')<br>
                                    data['a']<br>
                                    data['b']
                                </p>

                                <hr>

                                <h3>NumPy vs Pandas</h3>

                                <p><b>Use NumPy when:</b></p>
                                <ul>
                                    <li>Data numerical ho</li>
                                    <li>Homogeneous data ho</li>
                                    <li>Heavy computation ho</li>
                                </ul>

                                <p><b>Use Pandas when:</b></p>
                                <ul>
                                    <li>CSV / Excel / tabular data ho</li>
                                    <li>Mixed data types ho</li>
                                    <li>Data cleaning aur analysis ho</li>
                                </ul>

                                <hr>

                                <h3>Quick Comparison</h3>

                                <ul>
                                    <li>np.save / load → fastest, binary</li>
                                    <li>np.savetxt / loadtxt → readable, slow</li>
                                    <li>np.genfromtxt → mixed data</li>
                                    <li>np.savez → multiple arrays</li>
                                </ul>

                                <hr>

                                <p><b>Memory Trick:</b><br>
                                    Fast + numeric → NumPy<br>
                                    Tabular + messy → Pandas
                                </p>

                                <hr>
                                <hr>

                                <h2>9. Linear Algebra with NumPy</h2>
                                <hr>

                                <p>
                                    NumPy ka <b>linalg</b> module high-performance
                                    linear algebra operations provide karta hai.
                                </p>

                                <p><b>Use cases:</b></p>
                                <ul>
                                    <li>Machine Learning</li>
                                    <li>Data Science</li>
                                    <li>Optimization</li>
                                    <li>Computer Vision</li>
                                    <li>Scientific Computing</li>
                                </ul>

                                <hr>

                                <h3>np.linalg.det() – Determinant</h3>

                                <p>
                                    Square matrix ka determinant nikalta hai.
                                </p>

                                <p><b>Important:</b></p>
                                <ul>
                                    <li>Sirf square matrix</li>
                                    <li>det = 0 ⇒ inverse exist nahi karta</li>
                                </ul>

                                <hr>

                                <h3>np.linalg.inv() – Matrix Inverse</h3>

                                <ul>
                                    <li>Sirf square matrix</li>
                                    <li>Determinant ≠ 0 hona chahiye</li>
                                </ul>

                                <hr>

                                <h3>np.linalg.eig() – Eigenvalues & Eigenvectors</h3>

                                <p>
                                    Eigenvalues (λ) aur eigenvectors (v) nikalta hai.
                                </p>

                                <p>
                                    a · v = λ · v
                                </p>

                                <ul>
                                    <li>Eigenvectors columns me hote hain</li>
                                    <li>Diagonalization me use hota hai</li>
                                </ul>

                                <hr>

                                <h3>np.linalg.svd() – Singular Value Decomposition</h3>

                                <p>
                                    A = U · Σ · V<sup>T</sup>
                                </p>

                                <p><b>Use cases:</b></p>
                                <ul>
                                    <li>PCA</li>
                                    <li>Dimensionality reduction</li>
                                    <li>Noise reduction</li>
                                    <li>Recommendation systems</li>
                                </ul>

                                <hr>

                                <h3>Solving Linear Equations (Ax = b)</h3>

                                <p>
                                    np.linalg.solve(A, b)
                                </p>

                                <ul>
                                    <li>Square aur non-singular matrix chahiye</li>
                                    <li>inv() se faster aur accurate</li>
                                </ul>

                                <hr>

                                <h3>np.linalg.norm() – Norm</h3>

                                <p>
                                    Vector / matrix ka magnitude nikalta hai.
                                </p>

                                <ul>
                                    <li>ord=1 → Manhattan norm</li>
                                    <li>ord=2 → Euclidean norm</li>
                                    <li>ord=∞ → Max norm</li>
                                </ul>

                                <hr>

                                <h3>Orthogonality</h3>

                                <p>
                                    Do vectors orthogonal hote hain agar
                                    unka dot product = 0 ho.
                                </p>

                                <hr>

                                <h3>Important Linear Algebra Rules</h3>

                                <ul>
                                    <li>det ≠ 0 ⇒ inverse possible</li>
                                    <li>solve() > inv() for equations</li>
                                    <li>Eigenvalues sirf square matrix ke</li>
                                    <li>SVD rectangular matrix par bhi kaam karta hai</li>
                                    <li>Orthogonal vectors ka dot = 0</li>
                                </ul>

                                <hr>

                                <h3>One-line Memory Trick</h3>

                                <ul>
                                    <li>det → invertible check</li>
                                    <li>inv → undo matrix</li>
                                    <li>eig → direction + scale</li>
                                    <li>svd → powerful decomposition</li>
                                    <li>solve → direct equation solver</li>
                                    <li>norm → magnitude</li>
                                </ul>

                                <hr>
                                <hr>
                                <h2>10. NumPy for Data Analysis</h2>
                                <hr>

                                <p>
                                    NumPy data analysis me use hota hai:
                                </p>

                                <ul>
                                    <li>Raw data clean karne ke liye</li>
                                    <li>Missing values handle karne ke liye</li>
                                    <li>Multiple datasets combine karne ke liye</li>
                                    <li>Fast numerical computation ke liye</li>
                                </ul>

                                <hr>

                                <h3>Handling Missing Data (NaN, Inf)</h3>

                                <h4>NaN (Not a Number)</h4>
                                <p>Missing ya undefined values ko represent karta hai.</p>

                                <h4>Inf / -Inf</h4>
                                <p>Infinite values (overflow, division by zero).</p>

                                <h4>Check NaN / Inf</h4>

                                <ul>
                                    <li>np.isnan(a) → NaN check</li>
                                    <li>np.isinf(a) → Inf check</li>
                                    <li>np.isfinite(a) → valid numbers check</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, np.nan, np.inf, 5])<br><br>
                                    np.isnan(a)<br>
                                    [False False True False False]<br><br>
                                    np.isfinite(a)<br>
                                    [ True True False False True ]
                                </p>

                                <hr>

                                <h3>NaN-safe Statistical Functions</h3>

                                <p>
                                    Normal functions NaN ke saath fail ho jaate hain,
                                    isliye <b>nan-functions</b> use karte hain.
                                </p>

                                <ul>
                                    <li>np.nanmean()</li>
                                    <li>np.nanstd()</li>
                                    <li>np.nanmin()</li>
                                    <li>np.nanmax()</li>
                                    <li>np.nansum()</li>
                                </ul>

                                <p><b>Example:</b></p>
                                <p>
                                    a = np.array([1, 2, np.nan, 4])<br>
                                    np.mean(a) → NaN<br>
                                    np.nanmean(a) → 2.33
                                </p>

                                <hr>

                                <h3>Boolean Masking for Data Cleaning</h3>

                                <p><b>Remove NaN values:</b></p>
                                <p>clean = a[~np.isnan(a)]</p>

                                <p><b>Replace invalid values:</b></p>
                                <p>
                                    a[np.isnan(a)] = 0<br>
                                    a[np.isinf(a)] = 0
                                </p>

                                <p><b>Condition-based filtering:</b></p>
                                <p>
                                    data = np.array([10, -5, 20, -2, 30])<br>
                                    clean = data[data &gt; 0]
                                </p>

                                <hr>

                                <h3>Converting Python Data Structures</h3>

                                <ul>
                                    <li>List → np.array(list)</li>
                                    <li>Tuple → np.array(tuple)</li>
                                    <li>Set → np.array(list(set)) (unordered)</li>
                                </ul>

                                <hr>

                                <h3>Combining Multiple Datasets</h3>

                                <p><b>Using concatenate:</b></p>
                                <p>np.concatenate((a, b))</p>

                                <p><b>Stacking:</b></p>
                                <ul>
                                    <li>np.vstack() → row-wise</li>
                                    <li>np.hstack() → column-wise</li>
                                </ul>

                                <hr>

                                <h3>Real-world Data Analysis Flow</h3>

                                <ol>
                                    <li>Raw data load karo</li>
                                    <li>NaN / Inf identify karo</li>
                                    <li>Boolean masking se clean karo</li>
                                    <li>nan-functions se stats nikalo</li>
                                    <li>Datasets combine karo</li>
                                </ol>

                                <hr>

                                <h3>Important Notes</h3>

                                <ul>
                                    <li>np.nan != np.nan (NaN kabhi equal nahi hota)</li>
                                    <li>nan-functions mandatory hote hain</li>
                                    <li>Boolean masking fastest cleaning method</li>
                                    <li>Heavy tabular data ke liye Pandas better</li>
                                </ul>

                                <hr>

                                <p><b>Memory Trick:</b><br>
                                    Clean → Filter → Compute → Combine
                                </p>

                                <hr>
                                <hr>

                                <h2>11. NumPy in Machine Learning</h2>
                                <hr>

                                <p>
                                    NumPy ML ke core concepts ko <b>scratch se implement</b> karne me help karta hai.
                                </p>

                                <p>
                                    Ye foundation banata hai:
                                </p>

                                <ul>
                                    <li>Scikit-learn</li>
                                    <li>TensorFlow</li>
                                    <li>PyTorch</li>
                                </ul>

                                <hr>

                                <h3>11.1 Data Preprocessing</h3>

                                <h4>Min-Max Scaling</h4>

                                <p>
                                    Formula:<br>
                                    (x - min) / (max - min)
                                </p>

                                <p><b>Use:</b></p>
                                <ul>
                                    <li>Fast gradient descent</li>
                                    <li>Equal feature contribution</li>
                                </ul>

                                <hr>

                                <h4>Z-score Normalization</h4>

                                <p>
                                    Formula:<br>
                                    (x - mean) / std
                                </p>

                                <p><b>Use:</b></p>
                                <ul>
                                    <li>Normally distributed data</li>
                                    <li>Linear / Logistic regression</li>
                                </ul>

                                <hr>

                                <h4>One-Hot Encoding</h4>

                                <p>
                                    Categorical labels ko numeric vectors me convert karta hai.
                                </p>

                                <p>
                                    one_hot = np.eye(num_classes)[labels]
                                </p>

                                <hr>

                                <h4>Train-Test Split (Manual)</h4>

                                <p>
                                    np.random.shuffle(data)<br>
                                    split_idx = int(0.8 * len(data))
                                </p>

                                <p>
                                    Random shuffle mandatory hai,
                                    warna biased split ho sakta hai.
                                </p>

                                <hr>

                                <h3>11.2 Implementing ML Concepts Manually</h3>

                                <h4>Gradient Descent</h4>

                                <p>
                                    Loss minimize karne ka iterative algorithm.
                                </p>

                                <ul>
                                    <li>High learning rate → divergence</li>
                                    <li>Low learning rate → slow learning</li>
                                </ul>

                                <hr>

                                <h4>Linear Regression</h4>

                                <p>
                                    Vectorized prediction:<br>
                                    X @ weights
                                </p>

                                <hr>

                                <h4>Logistic Regression</h4>

                                <p>
                                    Sigmoid output probability deta hai (0–1).
                                </p>

                                <p>
                                    Threshold (0.5) se class decide hoti hai.
                                </p>

                                <hr>

                                <h4>Loss Functions</h4>

                                <ul>
                                    <li>MSE → Regression</li>
                                    <li>Cross-Entropy → Classification</li>
                                </ul>

                                <hr>

                                <h3>11.3 Vectorized ML Implementations</h3>

                                <p>
                                    ML me loops avoid karna <b>mandatory</b> hai.
                                </p>

                                <ul>
                                    <li>10x–100x faster</li>
                                    <li>GPU / parallel friendly</li>
                                    <li>Industry standard</li>
                                </ul>

                                <hr>

                                <h3>Common ML Mistakes</h3>

                                <ul>
                                    <li>❌ Data scale nahi kiya</li>
                                    <li>❌ Learning rate galat</li>
                                    <li>❌ Loops use kiye</li>
                                    <li>❌ Bias term bhool gaye</li>
                                </ul>

                                <hr>

                                <h3>Quick ML + NumPy Summary</h3>

                                <ul>
                                    <li>Scaling → stable learning</li>
                                    <li>Normalization → centered data</li>
                                    <li>Gradient Descent → optimization</li>
                                    <li>Sigmoid → probability</li>
                                    <li>Vectorization → speed</li>
                                </ul>

                                <hr>

                                <p><b>Memory Trick:</b><br>
                                    Preprocess → Vectorize → Optimize → Predict
                                </p>

                                <hr>
                                <hr>
                                <h2>12. Expert-Level NumPy Topics</h2>
                                <hr>

                                <p>
                                    Ye topics large-scale data, performance tuning
                                    aur advanced data structures ke liye use hote hain.
                                </p>

                                <p><b>Mostly used in:</b></p>
                                <ul>
                                    <li>Big data handling</li>
                                    <li>ML infrastructure</li>
                                    <li>Scientific computing</li>
                                    <li>High-performance pipelines</li>
                                </ul>

                                <hr>

                                <h2>12.1 Broadcasting Across Tensors</h2>
                                <hr>

                                <p>
                                    3D ya usse zyada dimensional arrays ko <b>tensors</b> kehte hain.
                                </p>

                                <p>
                                    Broadcasting rules tensors par bhi <b>same</b> rehte hain.
                                </p>

                                <hr>

                                <h3>High-dimensional Array Example</h3>

                                <p>
                                    tensor = np.random.rand(2, 3, 4)<br>
                                    shape = (2, 3, 4)
                                </p>

                                <hr>

                                <h3>Tensor Broadcasting Example</h3>

                                <p>
                                    a = np.random.rand(2, 1, 4) &nbsp;&nbsp;# shape (2,1,4)<br>
                                    b = np.random.rand(3, 4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# shape (3,4)<br><br>
                                    result = a + b
                                </p>

                                <p><b>Explanation:</b></p>
                                <ul>
                                    <li>b ko treat kiya gaya as (1,3,4)</li>
                                    <li>a ke middle dimension (1) ko stretch kiya gaya</li>
                                    <li>Final shape = (2,3,4)</li>
                                </ul>

                                <hr>

                                <h3>Expert Tip</h3>

                                <p>
                                    Broadcasting samajhne ke liye
                                    <b>shapes ko hamesha right se align</b> karke dekho.
                                </p>

                                <hr>

                                <h2>12.2 Structured and Record Arrays</h2>
                                <hr>

                                <p>
                                    Structured arrays tab use hote hain
                                    jab ek array me <b>multiple data types</b> store karne ho.
                                </p>

                                <hr>

                                <h3>Define Structured dtype</h3>

                                <p>
                                    dtype = np.dtype([<br>
                                    &nbsp;&nbsp;('name', 'U10'),<br>
                                    &nbsp;&nbsp;('age', 'i4'),<br>
                                    &nbsp;&nbsp;('height', 'f8')<br>
                                    ])
                                </p>

                                <p>
                                    data = np.array([<br>
                                    &nbsp;&nbsp;('Alice', 25, 5.5),<br>
                                    &nbsp;&nbsp;('Bob', 30, 6.0)<br>
                                    ], dtype=dtype)
                                </p>

                                <hr>

                                <h3>Access Fields</h3>

                                <p>
                                    data['name'] → ['Alice' 'Bob']<br>
                                    data['age'] → [25 30]
                                </p>

                                <hr>

                                <h3>Important Reality Check</h3>

                                <ul>
                                    <li>Structured arrays fast hote hain</li>
                                    <li>Memory-efficient hote hain</li>
                                    <li>Par manipulation difficult hoti hai</li>
                                </ul>

                                <p>
                                    Complex tabular operations ke liye
                                    <b>Pandas better choice</b> hota hai.
                                </p>

                                <hr>

                                <h2>12.3 Memory Mapping (Huge Files)</h2>
                                <hr>

                                <p>
                                    Jab data RAM me fit na ho,
                                    tab <b>memory mapping</b> use ki jati hai.
                                </p>

                                <hr>

                                <h3>np.memmap()</h3>

                                <p>
                                    Disk file ko array jaise treat karta hai.
                                </p>

                                <ul>
                                    <li>Sirf required chunk RAM me load hota hai</li>
                                    <li>Full data memory me nahi aata</li>
                                </ul>

                                <p><b>Syntax:</b></p>
                                <p>np.memmap(filename, dtype, mode, shape)</p>

                                <p><b>Example:</b></p>
                                <p>
                                    fp = np.memmap(<br>
                                    &nbsp;&nbsp;'large_file.dat',<br>
                                    &nbsp;&nbsp;dtype='float32',<br>
                                    &nbsp;&nbsp;mode='w+',<br>
                                    &nbsp;&nbsp;shape=(1000, 1000)<br>
                                    )<br><br>
                                    fp[:] = np.random.rand(1000, 1000)<br>
                                    fp.flush()
                                </p>

                                <hr>

                                <h3>Use Cases</h3>

                                <ul>
                                    <li>Huge datasets</li>
                                    <li>Streaming data</li>
                                    <li>Limited RAM systems</li>
                                </ul>

                                <hr>

                                <h3>Caution</h3>

                                <ul>
                                    <li>Disk I/O slow hota hai</li>
                                    <li>Random access kam rakho</li>
                                </ul>

                                <hr>

                                <h2>12.4 Custom Dtypes</h2>
                                <hr>

                                <p>
                                    NumPy me <b>custom memory layout</b> define kar sakte ho.
                                </p>

                                <hr>

                                <h3>Fixed-length Strings</h3>

                                <p>
                                    arr = np.array(['hello', 'world'], dtype='U5')
                                </p>

                                <hr>

                                <h3>Nested / Structured dtype</h3>

                                <p>
                                    dtype = np.dtype([<br>
                                    &nbsp;&nbsp;('person', [<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;('name', 'U10'),<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;('age', 'i4')<br>
                                    &nbsp;&nbsp;])<br>
                                    ])
                                </p>

                                <p>
                                    data = np.array([<br>
                                    &nbsp;&nbsp;(( 'Alice', 25 ),),<br>
                                    &nbsp;&nbsp;(( 'Bob', 30 ),)<br>
                                    ], dtype=dtype)
                                </p>

                                <hr>

                                <h3>Expert Note</h3>

                                <ul>
                                    <li>Custom dtypes memory optimize karte hain</li>
                                    <li>Par readability kam ho jati hai</li>
                                </ul>

                                <hr>

                                <h2>12.5 Performance Benchmarking</h2>
                                <hr>

                                <p>
                                    Expert-level NumPy me
                                    <b>measure karna mandatory</b> hota hai.
                                </p>

                                <hr>

                                <h3>np.vectorize() – Reality Check</h3>

                                <p>
                                    @np.vectorize<br>
                                    def square(x):<br>
                                    &nbsp;&nbsp;return x**2
                                </p>

                                <ul>
                                    <li>Syntax clean hota hai</li>
                                    <li>Performance improve nahi karta</li>
                                    <li>Internally Python loop hi hota hai</li>
                                </ul>

                                <hr>

                                <h3>numexpr (High Performance)</h3>

                                <p>
                                    Complex expressions ko optimized way me evaluate karta hai.
                                </p>

                                <p>
                                    Temporary arrays kam banata hai.
                                </p>

                                <p><b>Example:</b></p>
                                <p>
                                    import numexpr as ne<br><br>
                                    a = np.random.rand(1000)<br>
                                    b = np.random.rand(1000)<br><br>
                                    result = ne.evaluate('a**2 + b**2')
                                </p>

                                <hr>

                                <h3>timeit (Benchmarking)</h3>

                                <p>
                                    import timeit<br><br>
                                    timeit.timeit(<br>
                                    &nbsp;&nbsp;'np.sum(a)',<br>
                                    &nbsp;&nbsp;globals={'a': np.random.rand(1000)},<br>
                                    &nbsp;&nbsp;number=1000<br>
                                    )
                                </p>

                                <hr>

                                <h3>Best Practice</h3>

                                <ul>
                                    <li>Pehle code likho</li>
                                    <li>Phir measure karo</li>
                                    <li>Phir optimize karo</li>
                                </ul>

                                <hr>

                                <h2>Expert Performance Rules</h2>
                                <hr>

                                <ul>
                                    <li>Broadcasting &gt; loops</li>
                                    <li>Vectorization mandatory</li>
                                    <li>Contiguous memory faster</li>
                                    <li>Huge data ke liye memmap</li>
                                    <li>Optimize karne se pehle measure</li>
                                </ul>

                                <hr>

                                <h3>One-line Expert Summary</h3>

                                <p>
                                    <b>Expert NumPy = Broadcasting + Memory Control + Measurement</b>
                                </p>

                                <hr>
                                <hr>
                                <h2>13. NumPy Project Work (Final Stage)</h2>
                                <h3>Beginner Project: Temperature Analysis</h3>
                                <hr>

                                <h4>Project Objective</h4>
                                <ul>
                                    <li>Daily temperature data ka analysis karna using NumPy</li>
                                    <li>Real-life data analysis ka basic flow samajhna</li>
                                </ul>

                                <hr>
                                <h4>Problem Statement</h4>

                                <p><b>Given:</b> 30 days ka daily temperature data (°C)</p>

                                <p><b>Tasks:</b></p>
                                <ol>
                                    <li>Basic statistics nikalna</li>
                                    <li>Hot aur cold days identify karna</li>
                                    <li>Data normalization</li>
                                    <li>Temperature trends analyze karna</li>
                                </ol>

                                <hr>
                                <h4>Step 1: Create Dataset</h4>

                                <pre>
import numpy as np

# 30 days temperature data
temps = np.array([
    28, 30, 29, 31, 32, 33, 34,
    35, 36, 34, 33, 32, 31, 30,
    29, 28, 27, 26, 25, 26, 27,
    28, 29, 30, 31, 32, 33, 34,
    35, 36
])
</pre>

                                <hr>
                                <h4>Step 2: Basic Statistics</h4>

                                <pre>
avg_temp = np.mean(temps)
max_temp = np.max(temps)
min_temp = np.min(temps)
std_temp = np.std(temps)
</pre>

                                <h5>Output Meaning</h5>
                                <ul>
                                    <li><b>avg_temp</b> → overall weather trend</li>
                                    <li><b>max_temp</b> → hottest day</li>
                                    <li><b>min_temp</b> → coldest day</li>
                                    <li><b>std_temp</b> → temperature variation</li>
                                </ul>

                                <hr>
                                <h4>Step 3: Hot & Cold Days (Boolean Masking)</h4>

                                <pre>
hot_days = temps[temps > 32]
cold_days = temps[temps < 28]
</pre>

                                <h5>Why Boolean Masking?</h5>
                                <ul>
                                    <li>Fast filtering</li>
                                    <li>No loops</li>
                                    <li>Clean code</li>
                                </ul>

                                <hr>
                                <h4>Step 4: Day-wise Analysis</h4>

                                <pre>
hottest_day = np.argmax(temps)
coldest_day = np.argmin(temps)
</pre>

                                <p>
                                    <b>Interpretation:</b><br>
                                    Index = day number (0-based)<br>
                                    Actual calendar day = index + 1
                                </p>

                                <hr>
                                <h4>Step 5: Normalize Temperature Data</h4>

                                <pre>
normalized = (temps - min_temp) / (max_temp - min_temp)
</pre>

                                <h5>Why Normalize?</h5>
                                <ul>
                                    <li>Data ML-ready hota hai</li>
                                    <li>Scale differences remove hote hain</li>
                                </ul>

                                <hr>
                                <h4>Step 6: Weekly Analysis (Reshape)</h4>

                                <pre>
weekly = temps.reshape(5, 6)
weekly_avg = np.mean(weekly, axis=1)
</pre>

                                <p><b>Use Case:</b> Har week ka weather trend analysis</p>

                                <hr>
                                <h4>Step 7: Trend Detection</h4>

                                <pre>
daily_change = np.diff(temps)
</pre>

                                <p>
                                    Positive value → temperature increase<br>
                                    Negative value → temperature decrease
                                </p>

                                <hr>
                                <h4>Final Insights (Project Conclusion)</h4>
                                <ul>
                                    <li>Average temperature mostly stable hai</li>
                                    <li>Peak temperature last weeks me zyada hai</li>
                                    <li>Cold days starting weeks me zyada hain</li>
                                    <li>Overall warming trend visible hai</li>
                                </ul>

                                <hr>
                                <h4>Concepts Used (Interview Gold)</h4>
                                <ul>
                                    <li>NumPy arrays</li>
                                    <li>mean, min, max, std</li>
                                    <li>Boolean masking</li>
                                    <li>argmax / argmin</li>
                                    <li>Reshape</li>
                                    <li>Axis-based operations</li>
                                    <li>Normalization</li>
                                    <li>diff() for trend analysis</li>
                                </ul>

                                <hr>
                                <h4>How to Explain in Interview</h4>
                                <p>
                                    "I used NumPy to analyze daily temperature data.
                                    I cleaned, filtered, normalized and reshaped the data
                                    and extracted insights using vectorized operations
                                    without using loops."
                                </p>

                                <hr>
                                <h4>Next Upgrade Ideas (Optional)</h4>
                                <ul>
                                    <li>Add missing values (NaN handling)</li>
                                    <li>Compare multiple cities</li>
                                    <li>Visualize using Matplotlib</li>
                                    <li>Convert to Pandas DataFrame</li>
                                </ul>

                                <hr>
                                <hr>
                                <h2>13. NumPy Project Work (Final Stage)</h2>
                                <h3>Beginner Project: Student Marks Analysis</h3>
                                <hr>

                                <h4>Project Objective</h4>
                                <ul>
                                    <li>Students ke marks ka analysis karna using NumPy</li>
                                    <li>Performance, pass/fail, topper, average jaise insights nikalna</li>
                                </ul>

                                <hr>
                                <h4>Problem Statement</h4>

                                <p><b>Given:</b> 10 students ke marks (out of 100)</p>

                                <p><b>Tasks:</b></p>
                                <ol>
                                    <li>Average, max, min marks nikalna</li>
                                    <li>Pass aur fail students identify karna</li>
                                    <li>Grade distribution banana</li>
                                    <li>Topper aur weak students find karna</li>
                                    <li>Marks normalization (ML-ready)</li>
                                </ol>

                                <hr>
                                <h4>Step 1: Create Dataset</h4>

                                <pre>
import numpy as np

marks = np.array([45, 67, 89, 90, 56, 78, 92, 34, 60, 73])
</pre>

                                <hr>
                                <h4>Step 2: Basic Statistics</h4>

                                <pre>
avg_marks = np.mean(marks)
max_marks = np.max(marks)
min_marks = np.min(marks)
std_marks = np.std(marks)
</pre>

                                <h5>Meaning</h5>
                                <ul>
                                    <li><b>avg_marks</b> → class performance</li>
                                    <li><b>max_marks</b> → highest scorer</li>
                                    <li><b>min_marks</b> → weakest score</li>
                                    <li><b>std_marks</b> → marks variation</li>
                                </ul>

                                <hr>
                                <h4>Step 3: Pass / Fail Analysis (Boolean Masking)</h4>

                                <p><b>Assume:</b> Pass marks = 40</p>

                                <pre>
pass_students = marks[marks >= 40]
fail_students = marks[marks < 40]
</pre>

                                <h5>Insight</h5>
                                <ul>
                                    <li>Boolean masking fast hoti hai</li>
                                    <li>No loops required</li>
                                    <li>Code clean aur readable hota hai</li>
                                </ul>

                                <hr>
                                <h4>Step 4: Topper & Weak Student</h4>

                                <pre>
topper_index = np.argmax(marks)
weak_index = np.argmin(marks)
</pre>

                                <p>
                                    <b>Interpretation:</b><br>
                                    Index = student number (0-based)<br>
                                    Real life me +1 karke roll number bol sakte ho
                                </p>

                                <hr>
                                <h4>Step 5: Grade Distribution</h4>

                                <p><b>Grade Criteria:</b></p>
                                <ul>
                                    <li>A → marks ≥ 85</li>
                                    <li>B → marks 70–84</li>
                                    <li>C → marks 50–69</li>
                                    <li>D → marks &lt; 50</li>
                                </ul>

                                <pre>
grade_A = marks[marks >= 85]
grade_B = marks[(marks >= 70) & (marks < 85)]
grade_C = marks[(marks >= 50) & (marks < 70)]
grade_D = marks[marks < 50]
</pre>

                                <h5>Why this matters?</h5>
                                <ul>
                                    <li>Class grading pattern samajh aata hai</li>
                                    <li>Teachers aur institutes ke liye useful insight</li>
                                </ul>

                                <hr>
                                <h4>Step 6: Marks Normalization</h4>

                                <pre>
normalized_marks = (marks - min_marks) / (max_marks - min_marks)
</pre>

                                <h5>Why normalize?</h5>
                                <ul>
                                    <li>ML algorithms ke liye data ready hota hai</li>
                                    <li>Scale differences remove hote hain</li>
                                </ul>

                                <hr>
                                <h4>Step 7: Performance Comparison</h4>

                                <pre>
above_avg = marks[marks > avg_marks]
below_avg = marks[marks < avg_marks]
</pre>

                                <hr>
                                <h4>Final Insights (Conclusion)</h4>
                                <ul>
                                    <li>Class ka average performance moderate hai</li>
                                    <li>Few students high achievers hain</li>
                                    <li>Kuch students ko extra support chahiye</li>
                                    <li>Grade distribution balanced nahi hai</li>
                                    <li>Data ML preprocessing ke liye ready hai</li>
                                </ul>

                                <hr>
                                <h4>Concepts Used (Interview Gold)</h4>
                                <ul>
                                    <li>NumPy arrays</li>
                                    <li>mean, max, min, std</li>
                                    <li>Boolean masking</li>
                                    <li>argmax / argmin</li>
                                    <li>Conditional filtering</li>
                                    <li>Normalization</li>
                                    <li>Data analysis mindset</li>
                                </ul>

                                <hr>
                                <h4>How to Explain in Interview</h4>
                                <p>
                                    "I used NumPy to analyze student marks.
                                    I calculated statistics, filtered pass and fail students,
                                    identified toppers, created grade distributions,
                                    and normalized data using vectorized operations
                                    without using loops."
                                </p>

                                <hr>
                                <h4>Upgrade Ideas (Optional)</h4>
                                <ul>
                                    <li>Add subject-wise marks (2D array)</li>
                                    <li>Handle missing marks (NaN)</li>
                                    <li>Visualize using Matplotlib</li>
                                    <li>Convert to Pandas for report</li>
                                    <li>Predict pass/fail using ML</li>
                                </ul>

                                <hr>
                                <hr>
                                <h2>13. NumPy Project Work (Final Stage)</h2>
                                <h3>Beginner Project: Electricity Bill Calculation</h3>
                                <hr>

                                <h4>Project Objective</h4>
                                <ul>
                                    <li>Consumers ke electricity usage ka analysis karna</li>
                                    <li>Bill calculation, high/low usage aur statistics nikalna using NumPy</li>
                                </ul>

                                <hr>
                                <h4>Problem Statement</h4>

                                <p><b>Given:</b> 10 consumers ke monthly electricity units</p>

                                <p><b>Billing Rules:</b></p>
                                <ul>
                                    <li>0 – 100 units → ₹5 per unit</li>
                                    <li>101 – 300 units → ₹7 per unit</li>
                                    <li>Above 300 units → ₹10 per unit</li>
                                </ul>

                                <p><b>Tasks:</b></p>
                                <ol>
                                    <li>Har consumer ka bill calculate karna</li>
                                    <li>Total aur average bill nikalna</li>
                                    <li>Highest aur lowest bill find karna</li>
                                    <li>High-usage consumers identify karna</li>
                                    <li>Units ko normalize karna (ML-ready)</li>
                                </ol>

                                <hr>
                                <h4>Step 1: Create Dataset</h4>

                                <pre>
import numpy as np

units = np.array([80, 150, 220, 340, 90, 410, 275, 60, 180, 320])
</pre>

                                <hr>
                                <h4>Step 2: Initialize Bill Array</h4>

                                <pre>
bill = np.zeros_like(units, dtype=float)
</pre>

                                <hr>
                                <h4>Step 3: Bill Calculation (Boolean Masking)</h4>

                                <pre>
# 0–100 units
bill[units <= 100] = units[units <= 100] * 5

# 101–300 units
mask_mid = (units > 100) & (units <= 300)
bill[mask_mid] = (100 * 5) + (units[mask_mid] - 100) * 7

# Above 300 units
mask_high = units > 300
bill[mask_high] = (
    100 * 5 +
    200 * 7 +
    (units[mask_high] - 300) * 10
)
</pre>

                                <h5>Why Boolean Masking?</h5>
                                <ul>
                                    <li>No loops required</li>
                                    <li>Code fast aur readable hota hai</li>
                                    <li>Real-world slab logic easily handle hota hai</li>
                                </ul>

                                <hr>
                                <h4>Step 4: Bill Statistics</h4>

                                <pre>
total_bill = np.sum(bill)
average_bill = np.mean(bill)
max_bill = np.max(bill)
min_bill = np.min(bill)
</pre>

                                <hr>
                                <h4>Step 5: Consumer Analysis</h4>

                                <pre>
highest_bill_consumer = np.argmax(bill)
lowest_bill_consumer = np.argmin(bill)
</pre>

                                <p>
                                    <b>Interpretation:</b><br>
                                    Index = consumer number (0-based)<br>
                                    Real life me +1 karke consumer ID bol sakte ho
                                </p>

                                <hr>
                                <h4>Step 6: High Usage Consumers</h4>

                                <pre>
high_usage = units[units > 300]
high_usage_bills = bill[units > 300]
</pre>

                                <hr>
                                <h4>Step 7: Normalization of Units</h4>

                                <pre>
normalized_units = (units - np.min(units)) / (np.max(units) - np.min(units))
</pre>

                                <h5>Why Normalize?</h5>
                                <ul>
                                    <li>ML models ke liye data scale-ready hota hai</li>
                                    <li>Comparison aur prediction easy ho jata hai</li>
                                </ul>

                                <hr>
                                <h4>Final Insights (Conclusion)</h4>
                                <ul>
                                    <li>Kuch consumers ka bill bahut high hai due to &gt;300 units</li>
                                    <li>Majority consumers mid-range slab me aate hain</li>
                                    <li>High usage directly bill spike karta hai</li>
                                    <li>Normalized data future ML prediction ke liye ready hai</li>
                                </ul>

                                <hr>
                                <h4>Concepts Used (Interview Gold)</h4>
                                <ul>
                                    <li>NumPy arrays</li>
                                    <li>Boolean masking</li>
                                    <li>Conditional logic without loops</li>
                                    <li>sum, mean, max, min</li>
                                    <li>argmax / argmin</li>
                                    <li>Data normalization</li>
                                    <li>Real-world billing logic</li>
                                </ul>

                                <hr>
                                <h4>How to Explain in Interview</h4>
                                <p>
                                    "I used NumPy to calculate electricity bills based on
                                    unit slabs. I applied boolean masking instead of loops,
                                    computed statistics, identified high-usage consumers,
                                    and normalized data for future ML use."
                                </p>

                                <hr>
                                <h4>Upgrade Ideas (Optional)</h4>
                                <ul>
                                    <li>Add fixed meter charge</li>
                                    <li>Add tax (GST) calculation</li>
                                    <li>Handle missing units (NaN)</li>
                                    <li>Monthly vs yearly comparison</li>
                                    <li>Visualization using Matplotlib</li>
                                    <li>Predict future bill using ML</li>
                                </ul>

                                <hr>
                                <hr>
                                <h2>INTERMEDIATE PROJECTS (NumPy Focused)</h2>
                                <hr>

                                <h3>1. Image Processing Basics (NumPy Only)</h3>

                                <hr>
                                <h4>Project Objective</h4>
                                <p>
                                    Image ko NumPy array ke form me treat karke
                                    basic image processing operations perform karna.
                                </p>

                                <h4>Key Concepts Used</h4>
                                <ul>
                                    <li>2D NumPy arrays</li>
                                    <li>Broadcasting</li>
                                    <li>Boolean masking</li>
                                    <li>Vectorization</li>
                                    <li>Normalization</li>
                                </ul>

                                <h4>Operations Implemented</h4>
                                <ol>
                                    <li>Brightness adjustment</li>
                                    <li>Contrast enhancement</li>
                                    <li>Thresholding (binary image)</li>
                                    <li>Image normalization (0–1 range)</li>
                                </ol>

                                <h4>Sample Logic</h4>
                                <pre>
image = image + brightness
image = image * contrast
binary = image > threshold
normalized = image / 255
</pre>

                                <h4>Real-life Use</h4>
                                <p>Image preprocessing before ML / Computer Vision models</p>

                                <h4>How to Explain (Interview)</h4>
                                <p>
                                    "I represented images as NumPy matrices and applied
                                    vectorized operations like brightness, contrast
                                    and thresholding without using loops."
                                </p>

                                <hr>

                                <h3>2. CSV Data Preprocessing (NumPy Only)</h3>

                                <hr>
                                <h4>Project Objective</h4>
                                <p>
                                    Raw CSV data ko clean, normalize aur analysis-ready
                                    banana using NumPy.
                                </p>

                                <h4>Key Concepts Used</h4>
                                <ul>
                                    <li>np.loadtxt / np.genfromtxt</li>
                                    <li>NaN handling</li>
                                    <li>Boolean masking</li>
                                    <li>Axis-based operations</li>
                                    <li>Normalization</li>
                                </ul>

                                <h4>Tasks Performed</h4>
                                <ol>
                                    <li>CSV file load karna</li>
                                    <li>Missing values detect karna</li>
                                    <li>Column-wise mean se NaN replace karna</li>
                                    <li>Data normalization</li>
                                    <li>Invalid rows remove karna</li>
                                </ol>

                                <h4>Sample Logic</h4>
                                <pre>
mean = np.nanmean(data, axis=0)
data[np.isnan(data)] = mean
normalized = (data - min) / (max - min)
</pre>

                                <h4>Real-life Use</h4>
                                <p>Data cleaning before analytics or ML pipeline</p>

                                <h4>How to Explain</h4>
                                <p>
                                    "I cleaned raw CSV data using nan-functions,
                                    boolean masking and prepared it for analysis."
                                </p>

                                <hr>

                                <h3>3. Simple ML Model – Linear Regression (NumPy Only)</h3>

                                <hr>
                                <h4>Project Objective</h4>
                                <p>
                                    Scikit-learn ke bina linear regression
                                    ko scratch se implement karna.
                                </p>

                                <h4>Key Concepts Used</h4>
                                <ul>
                                    <li>Matrix multiplication (@)</li>
                                    <li>Gradient descent</li>
                                    <li>Vectorization</li>
                                    <li>Loss function (MSE)</li>
                                </ul>

                                <h4>Implementation Steps</h4>
                                <ol>
                                    <li>Feature matrix (X) aur target (y)</li>
                                    <li>Weight initialization</li>
                                    <li>Gradient calculation</li>
                                    <li>Weight update</li>
                                    <li>Convergence check</li>
                                </ol>

                                <h4>Core Formula</h4>
                                <pre>
y_pred = X @ weights
gradient = (1/m) * X.T @ (y_pred - y)
weights = weights - lr * gradient
</pre>

                                <h4>Real-life Use</h4>
                                <p>Understanding machine learning internals</p>

                                <h4>How to Explain</h4>
                                <p>
                                    "I implemented linear regression using pure NumPy
                                    with fully vectorized gradient descent."
                                </p>

                                <hr>
                                <hr>

                                <h2>ADVANCED PROJECTS (Expert Level)</h2>
                                <hr>

                                <h3>4. Neural Network from Scratch (NumPy Only)</h3>

                                <hr>
                                <h4>Project Objective</h4>
                                <p>
                                    Deep learning ka core logic samajhna
                                    bina TensorFlow ya PyTorch.
                                </p>

                                <h4>Architecture</h4>
                                <ul>
                                    <li>Input layer</li>
                                    <li>One hidden layer</li>
                                    <li>Output layer</li>
                                    <li>Sigmoid activation</li>
                                </ul>

                                <h4>Key Concepts Used</h4>
                                <ul>
                                    <li>Forward propagation</li>
                                    <li>Backpropagation</li>
                                    <li>Chain rule</li>
                                    <li>Gradient descent</li>
                                </ul>

                                <h4>Steps</h4>
                                <ol>
                                    <li>Weight initialization</li>
                                    <li>Forward pass</li>
                                    <li>Loss calculation</li>
                                    <li>Backpropagation</li>
                                    <li>Weight update</li>
                                </ol>

                                <h4>Real-life Use</h4>
                                <p>Foundation for deep learning frameworks</p>

                                <h4>How to Explain</h4>
                                <p>
                                    "I built a neural network from scratch using NumPy
                                    by implementing forward and backward propagation."
                                </p>

                                <hr>

                                <h3>5. K-Means Clustering (NumPy Only)</h3>

                                <hr>
                                <h4>Project Objective</h4>
                                <p>
                                    Unsupervised learning algorithm
                                    ko scratch se implement karna.
                                </p>

                                <h4>Key Concepts Used</h4>
                                <ul>
                                    <li>Euclidean distance</li>
                                    <li>Broadcasting</li>
                                    <li>argmin</li>
                                    <li>Mean update</li>
                                    <li>Iterative optimization</li>
                                </ul>

                                <h4>Algorithm Steps</h4>
                                <ol>
                                    <li>Random centroids select karna</li>
                                    <li>Distance calculation</li>
                                    <li>Cluster assignment</li>
                                    <li>Centroid update</li>
                                    <li>Repeat till convergence</li>
                                </ol>

                                <h4>Core Logic</h4>
                                <pre>
distance = ||X - centroid||
label = argmin(distance)
centroid = mean(cluster_points)
</pre>

                                <h4>Real-life Use</h4>
                                <p>Customer segmentation, pattern discovery</p>

                                <h4>How to Explain</h4>
                                <p>
                                    "I implemented k-means clustering using NumPy
                                    by iteratively updating centroids."
                                </p>

                                <hr>

                                <h3>6. PCA (Principal Component Analysis – NumPy Only)</h3>

                                <hr>
                                <h4>Project Objective</h4>
                                <p>
                                    Dimensionality reduction technique
                                    ko math ke saath implement karna.
                                </p>

                                <h4>Key Concepts Used</h4>
                                <ul>
                                    <li>Mean centering</li>
                                    <li>Covariance matrix</li>
                                    <li>Eigenvalues & eigenvectors</li>
                                    <li>Projection</li>
                                </ul>

                                <h4>Steps</h4>
                                <ol>
                                    <li>Data center karna</li>
                                    <li>Covariance matrix nikalna</li>
                                    <li>Eigen decomposition</li>
                                    <li>Top components select karna</li>
                                    <li>Data project karna</li>
                                </ol>

                                <h4>Core Formula</h4>
                                <pre>
X_pca = X_centered @ eigenvectors
</pre>

                                <h4>Real-life Use</h4>
                                <p>Feature reduction, noise removal</p>

                                <hr>

                            </div>
                            <div class="row">
                                <div class="buttons padd-15">
                                    <a href="index.html#contact" class="btn hire-me">Enroll Now</a>
                                    <a href="index.html#classes" class="btn">Back to Classes</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <!-- Course Section End  -->
        </div>
        <!-- Main contact End  -->
    </div>
    <!-- Main container End  -->

    <!-- Style Switcher Start  -->
    <div class="style-switcher">
        <div class="style-switcher-toggler s-icon">
            <i class="fas fa-cog fa-spin"></i>
        </div>
        <div class="day-night s-icon">
            <i class="fas"></i>
        </div>

        <h4>Theme Colors</h4>
        <div class="colors">
            <span class="color-1" onclick="setActiveStyle('color-1')"></span>
            <span class="color-2" onclick="setActiveStyle('color-2')"></span>
            <span class="color-3" onclick="setActiveStyle('color-3')"></span>
            <span class="color-4" onclick="setActiveStyle('color-4')"></span>
            <span class="color-5" onclick="setActiveStyle('color-5')"></span>
        </div>
    </div>
    <!-- Style Switcher End  -->

    <!-- Scroll to Top Button -->
    <button class="scroll-to-top" id="scrollToTopBtn">
        <i class="fas fa-arrow-up"></i>
    </button>


    <!-- JS file  -->
    <script src="https://smtpjs.com/v3/smtp.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <!-- main java script section  -->
    <script src="JS/main.js"></script>
    <script src="JS/style-switcher.js"></script>

</body>

</html>
